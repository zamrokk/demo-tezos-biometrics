import { TransportType, ExtensionMessageTarget, TransportStatus, Origin } from '@airgap/beacon-types';
import { Transport, PeerManager, Logger, windowRef } from '@airgap/beacon-core';
import { PostMessageClient } from './PostMessageClient';
const logger = new Logger('PostMessageTransport');
let listeningForExtensions = false;
let extensionsPromise;
let extensions;
const addExtension = (extension) => {
    if (!extensions) {
        extensions = [];
    }
    if (!extensions.some((ext) => ext.id === extension.id)) {
        extensions.push(extension);
        windowRef.postMessage('extensionsUpdated', windowRef.location.origin);
    }
};
/**
 * @internalapi
 *
 *
 */
export class PostMessageTransport extends Transport {
    type = TransportType.POST_MESSAGE;
    constructor(name, keyPair, storage, storageKey) {
        super(name, new PostMessageClient(name, keyPair), new PeerManager(storage, storageKey));
    }
    static async isAvailable() {
        return new Promise((resolve) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const fn = (event) => {
                const data = event.data;
                if (data && data.payload === 'pong') {
                    resolve(true);
                    windowRef.removeEventListener('message', fn);
                }
            };
            windowRef.addEventListener('message', fn);
            const message = {
                target: ExtensionMessageTarget.EXTENSION,
                payload: 'ping'
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            windowRef.postMessage(message, windowRef.location.origin);
        });
    }
    static async getAvailableExtensions() {
        if (extensionsPromise) {
            return extensionsPromise;
        }
        if (extensions) {
            return extensions;
        }
        extensions = [];
        extensionsPromise = new Promise((resolve) => {
            PostMessageTransport.listenForExtensions();
            setTimeout(() => {
                resolve(extensions ?? []);
            }, 1000);
        }).finally(() => {
            extensionsPromise = undefined;
        });
        return extensionsPromise;
    }
    static listenForExtensions() {
        if (listeningForExtensions) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const fn = (event) => {
            if (event.source !== windowRef || event.origin !== windowRef.location.origin) {
                // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                return;
            }
            const data = event.data;
            const sender = data.sender;
            if (data && data.payload === 'pong' && sender) {
                logger.log('getAvailableExtensions', `extension "${sender.name}" is available`, sender);
                addExtension(sender);
            }
        };
        windowRef.addEventListener('message', fn);
        const message = {
            target: ExtensionMessageTarget.EXTENSION,
            payload: 'ping'
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        windowRef.postMessage(message, windowRef.location.origin);
        listeningForExtensions = true;
    }
    async connect() {
        logger.log('connect');
        if (this._isConnected !== TransportStatus.NOT_CONNECTED) {
            return;
        }
        this._isConnected = TransportStatus.CONNECTING;
        const knownPeers = await this.getPeers();
        if (knownPeers.length > 0) {
            logger.log('connect', `connecting to ${knownPeers.length} peers`);
            const connectionPromises = knownPeers.map(async (peer) => this.listen(peer.publicKey));
            Promise.all(connectionPromises).catch((error) => logger.error('connect', error));
        }
        await this.startOpenChannelListener();
        await super.connect();
    }
    async startOpenChannelListener() {
        //
    }
    async getPairingRequestInfo() {
        return this.client.getPairingRequestInfo();
    }
    async listen(publicKey) {
        logger.log('listen', publicKey);
        await this.client
            .listenForEncryptedMessage(publicKey, (message, context) => {
            const connectionContext = {
                origin: Origin.EXTENSION,
                id: context.id
            };
            this.notifyListeners(message, connectionContext).catch((error) => {
                throw error;
            });
        })
            .catch((error) => {
            throw error;
        });
    }
}
// Start loading wallets async so they will be ready when the modal is opened
PostMessageTransport.getAvailableExtensions();
//# sourceMappingURL=PostMessageTransport.js.map