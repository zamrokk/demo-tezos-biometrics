import { windowRef, Serializer, getSenderId, MessageBasedClient } from '@airgap/beacon-core';
import { openCryptobox, secretbox_NONCEBYTES, secretbox_MACBYTES } from '@airgap/beacon-utils';
import { ExtensionMessageTarget, Origin, ExtendedPostMessagePairingResponse } from '@airgap/beacon-types';
/**
 * @internalapi
 *
 *
 */
export class PostMessageClient extends MessageBasedClient {
    activeListeners = new Map();
    async init() {
        this.subscribeToMessages().catch(console.error);
    }
    async listenForEncryptedMessage(senderPublicKey, messageCallback) {
        if (this.activeListeners.has(senderPublicKey)) {
            return;
        }
        const callbackFunction = async (message, context) => {
            try {
                const decryptedMessage = await this.decryptMessage(senderPublicKey, message.encryptedPayload);
                // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                // TODO: Add check for correct decryption key / sender ID
                messageCallback(decryptedMessage, context);
            }
            catch (decryptionError) {
                /* NO-OP. We try to decode every message, but some might not be addressed to us. */
            }
        };
        this.activeListeners.set(senderPublicKey, callbackFunction);
    }
    async sendMessage(message, peer) {
        const payload = await this.encryptMessage(peer.publicKey, message);
        const targetId = peer?.extensionId;
        // if no targetId, we remove peer
        const msg = {
            target: ExtensionMessageTarget.EXTENSION,
            encryptedPayload: payload,
            targetId
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        windowRef.postMessage(msg, windowRef.location.origin);
    }
    async listenForChannelOpening(messageCallback) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const fn = async (event) => {
            if (event.source !== windowRef || event.origin !== windowRef.location.origin) {
                // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                return;
            }
            const data = event?.data?.message;
            if (data &&
                data.target === ExtensionMessageTarget.PAGE &&
                (await this.isChannelOpenMessage(data))) {
                const payload = Buffer.from(data.payload, 'hex');
                if (payload.length >= secretbox_NONCEBYTES + secretbox_MACBYTES) {
                    try {
                        const pairingResponse = JSON.parse(await openCryptobox(payload, this.keyPair.publicKey, this.keyPair.secretKey));
                        messageCallback(new ExtendedPostMessagePairingResponse(pairingResponse.id, pairingResponse.name, pairingResponse.publicKey, pairingResponse.version, await getSenderId(pairingResponse.publicKey), event?.data?.sender.id));
                    }
                    catch (decryptionError) {
                        /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                    }
                }
            }
        };
        windowRef.addEventListener('message', fn);
    }
    async sendPairingRequest(id) {
        const message = {
            target: ExtensionMessageTarget.EXTENSION,
            payload: await new Serializer().serialize(await this.getPairingRequestInfo()),
            targetId: id
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        windowRef.postMessage(message, windowRef.location.origin);
    }
    async isChannelOpenMessage(message) {
        return typeof message === 'object' && message.hasOwnProperty('payload');
    }
    async subscribeToMessages() {
        windowRef.addEventListener('message', (message) => {
            if (message.source !== windowRef ||
                message.origin !== windowRef.location.origin) {
                // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                return;
            }
            if (typeof message === 'object' && message) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const data = message.data;
                if (data.message && data.message.target === ExtensionMessageTarget.PAGE) {
                    this.activeListeners.forEach((listener) => {
                        listener(data.message, {
                            origin: Origin.EXTENSION,
                            id: data.sender.id || ''
                        });
                    });
                }
            }
        });
    }
}
//# sourceMappingURL=PostMessageClient.js.map