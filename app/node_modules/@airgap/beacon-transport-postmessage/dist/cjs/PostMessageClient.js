"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostMessageClient = void 0;
const beacon_core_1 = require("@airgap/beacon-core");
const beacon_utils_1 = require("@airgap/beacon-utils");
const beacon_types_1 = require("@airgap/beacon-types");
/**
 * @internalapi
 *
 *
 */
class PostMessageClient extends beacon_core_1.MessageBasedClient {
    constructor() {
        super(...arguments);
        this.activeListeners = new Map();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscribeToMessages().catch(console.error);
        });
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const callbackFunction = (message, context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const decryptedMessage = yield this.decryptMessage(senderPublicKey, message.encryptedPayload);
                    // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                    // TODO: Add check for correct decryption key / sender ID
                    messageCallback(decryptedMessage, context);
                }
                catch (decryptionError) {
                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                }
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
        });
    }
    sendMessage(message, peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = yield this.encryptMessage(peer.publicKey, message);
            const targetId = peer === null || peer === void 0 ? void 0 : peer.extensionId;
            // if no targetId, we remove peer
            const msg = {
                target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
                encryptedPayload: payload,
                targetId
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            beacon_core_1.windowRef.postMessage(msg, beacon_core_1.windowRef.location.origin);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const fn = (event) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (event.source !== beacon_core_1.windowRef || event.origin !== beacon_core_1.windowRef.location.origin) {
                    // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                    return;
                }
                const data = (_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.message;
                if (data &&
                    data.target === beacon_types_1.ExtensionMessageTarget.PAGE &&
                    (yield this.isChannelOpenMessage(data))) {
                    const payload = Buffer.from(data.payload, 'hex');
                    if (payload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES) {
                        try {
                            const pairingResponse = JSON.parse(yield (0, beacon_utils_1.openCryptobox)(payload, this.keyPair.publicKey, this.keyPair.secretKey));
                            messageCallback(new beacon_types_1.ExtendedPostMessagePairingResponse(pairingResponse.id, pairingResponse.name, pairingResponse.publicKey, pairingResponse.version, yield (0, beacon_core_1.getSenderId)(pairingResponse.publicKey), (_b = event === null || event === void 0 ? void 0 : event.data) === null || _b === void 0 ? void 0 : _b.sender.id));
                        }
                        catch (decryptionError) {
                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                        }
                    }
                }
            });
            beacon_core_1.windowRef.addEventListener('message', fn);
        });
    }
    sendPairingRequest(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
                payload: yield new beacon_core_1.Serializer().serialize(yield this.getPairingRequestInfo()),
                targetId: id
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            beacon_core_1.windowRef.postMessage(message, beacon_core_1.windowRef.location.origin);
        });
    }
    isChannelOpenMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return typeof message === 'object' && message.hasOwnProperty('payload');
        });
    }
    subscribeToMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            beacon_core_1.windowRef.addEventListener('message', (message) => {
                if (message.source !== beacon_core_1.windowRef ||
                    message.origin !== beacon_core_1.windowRef.location.origin) {
                    // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                    return;
                }
                if (typeof message === 'object' && message) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const data = message.data;
                    if (data.message && data.message.target === beacon_types_1.ExtensionMessageTarget.PAGE) {
                        this.activeListeners.forEach((listener) => {
                            listener(data.message, {
                                origin: beacon_types_1.Origin.EXTENSION,
                                id: data.sender.id || ''
                            });
                        });
                    }
                }
            });
        });
    }
}
exports.PostMessageClient = PostMessageClient;
//# sourceMappingURL=PostMessageClient.js.map