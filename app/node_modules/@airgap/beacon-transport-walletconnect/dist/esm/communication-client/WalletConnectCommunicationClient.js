import { BEACON_VERSION, CommunicationClient, Serializer, Logger, WCStorage } from '@airgap/beacon-core';
import { SignClient } from '@walletconnect/sign-client';
import { getSdkError } from '@walletconnect/utils';
import { ActiveAccountUnspecified, ActiveNetworkUnspecified, InvalidNetworkOrAccount, InvalidReceivedSessionNamespace, InvalidSession, MissingRequiredScope, NotConnected } from '../error';
import { BeaconErrorType, BeaconMessageType, ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse, PermissionScope } from '@airgap/beacon-types';
import { generateGUID, getAddressFromPublicKey } from '@airgap/beacon-utils';
const TEZOS_PLACEHOLDER = 'tezos';
const logger = new Logger('WalletConnectCommunicationClient');
export var PermissionScopeMethods;
(function (PermissionScopeMethods) {
    PermissionScopeMethods["GET_ACCOUNTS"] = "tezos_getAccounts";
    PermissionScopeMethods["OPERATION_REQUEST"] = "tezos_send";
    PermissionScopeMethods["SIGN"] = "tezos_sign";
})(PermissionScopeMethods || (PermissionScopeMethods = {}));
export var PermissionScopeEvents;
(function (PermissionScopeEvents) {
    PermissionScopeEvents["CHAIN_CHANGED"] = "chainChanged";
    PermissionScopeEvents["ACCOUNTS_CHANGED"] = "accountsChanged";
    PermissionScopeEvents["REQUEST_ACKNOWLEDGED"] = "requestAcknowledged";
})(PermissionScopeEvents || (PermissionScopeEvents = {}));
export class WalletConnectCommunicationClient extends CommunicationClient {
    wcOptions;
    activeListeners = new Map();
    channelOpeningListeners = new Map();
    static instance;
    signClient;
    storage = new WCStorage();
    session;
    activeAccount;
    activeNetwork;
    /**
     * this queue stores each active message id
     * [0] newest message
     * [length - 1] oldest message
     */
    messageIds = [];
    constructor(wcOptions) {
        super();
        this.wcOptions = wcOptions;
        this.getSignClient();
    }
    static getInstance(wcOptions) {
        if (!WalletConnectCommunicationClient.instance) {
            WalletConnectCommunicationClient.instance = new WalletConnectCommunicationClient(wcOptions);
        }
        return WalletConnectCommunicationClient.instance;
    }
    async listenForEncryptedMessage(senderPublicKey, messageCallback) {
        if (this.activeListeners.has(senderPublicKey)) {
            return;
        }
        const callbackFunction = async (message) => {
            messageCallback(message);
        };
        this.activeListeners.set(senderPublicKey, callbackFunction);
    }
    async listenForChannelOpening(messageCallback) {
        const callbackFunction = async (pairingResponse) => {
            messageCallback(pairingResponse);
        };
        this.channelOpeningListeners.set('channelOpening', callbackFunction);
    }
    async unsubscribeFromEncryptedMessages() {
        // implementation
    }
    async unsubscribeFromEncryptedMessage(_senderPublicKey) {
        // implementation
    }
    checkWalletReadiness(topic) {
        this.signClient?.core.pairing
            .ping({ topic })
            .then(() => {
            if (this.messageIds.length) {
                this.acknowledgeRequest(this.messageIds[0]);
            }
            else {
                const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                fun && fun('pending');
            }
        })
            .catch((error) => logger.error(error.message));
    }
    async sendMessage(_message, _peer) {
        const serializer = new Serializer();
        const message = (await serializer.deserialize(_message));
        if (!message) {
            return;
        }
        this.messageIds.unshift(message.id);
        switch (message.type) {
            case BeaconMessageType.PermissionRequest:
                this.requestPermissions(message);
                break;
            case BeaconMessageType.OperationRequest:
                this.sendOperations(message);
                break;
            case BeaconMessageType.SignPayloadRequest:
                this.signPayload(message);
                break;
            default:
                return;
        }
    }
    async fetchAccounts(topic, chainId) {
        const signClient = await this.getSignClient();
        return signClient.request({
            topic: topic,
            chainId: chainId,
            request: {
                method: PermissionScopeMethods.GET_ACCOUNTS,
                params: {}
            }
        });
    }
    async notifyListenersWithPermissionResponse(session, network) {
        let publicKey;
        if (session.sessionProperties?.pubkey &&
            session.sessionProperties?.algo &&
            session.sessionProperties?.address) {
            publicKey = session.sessionProperties?.pubkey;
            logger.log('[requestPermissions]: Have pubkey in sessionProperties, skipping "get_accounts" call', session.sessionProperties);
        }
        else {
            const accounts = this.getTezosNamespace(session.namespaces).accounts;
            const addressOrPbk = accounts[0].split(':', 3)[2];
            if (addressOrPbk.startsWith('edpk')) {
                publicKey = addressOrPbk;
            }
            else {
                if (network.type !== this.wcOptions.network) {
                    throw new Error('Network in permission request is not the same as preferred network!');
                }
                const result = await this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${network.type}`);
                if (!result || result.length < 1) {
                    throw new Error('No account shared by wallet');
                }
                if (result.some((account) => !account.pubkey)) {
                    throw new Error('Public Key in `tezos_getAccounts` is empty!');
                }
                publicKey = result[0]?.pubkey;
            }
        }
        if (!publicKey) {
            throw new Error('Public Key in `tezos_getAccounts` is empty!');
        }
        const permissionResponse = {
            type: BeaconMessageType.PermissionResponse,
            appMetadata: {
                senderId: session.pairingTopic,
                name: session.peer.metadata.name,
                icon: session.peer.metadata.icons[0]
            },
            publicKey,
            network,
            scopes: [PermissionScope.SIGN, PermissionScope.OPERATION_REQUEST],
            id: this.messageIds.pop() ?? '',
            walletType: 'implicit'
        };
        this.notifyListeners(session.pairingTopic, permissionResponse);
    }
    async requestPermissions(message) {
        logger.log('#### Requesting permissions');
        if (!this.getPermittedMethods().includes(PermissionScopeMethods.GET_ACCOUNTS)) {
            throw new MissingRequiredScope(PermissionScopeMethods.GET_ACCOUNTS);
        }
        if (this.activeAccount) {
            try {
                await this.openSession();
            }
            catch (error) {
                logger.error(error.message);
                return;
            }
        }
        this.setDefaultAccountAndNetwork();
        this.notifyListenersWithPermissionResponse(this.getSession(), message.network);
    }
    /**
     * @description Once the session is establish, send payload to be approved and signed by the wallet.
     * @error MissingRequiredScope is thrown if permission to sign payload was not granted
     */
    async signPayload(signPayloadRequest) {
        const signClient = await this.getSignClient();
        const session = this.getSession();
        if (!this.getPermittedMethods().includes(PermissionScopeMethods.SIGN)) {
            throw new MissingRequiredScope(PermissionScopeMethods.SIGN);
        }
        const network = this.getActiveNetwork();
        const account = await this.getPKH();
        this.validateNetworkAndAccount(network, account);
        this.checkWalletReadiness(session.pairingTopic);
        // TODO: Type
        signClient
            .request({
            topic: session.topic,
            chainId: `${TEZOS_PLACEHOLDER}:${network}`,
            request: {
                method: PermissionScopeMethods.SIGN,
                params: {
                    account: account,
                    payload: signPayloadRequest.payload
                }
            }
        })
            .then((response) => {
            const signPayloadResponse = {
                type: BeaconMessageType.SignPayloadResponse,
                signingType: signPayloadRequest.signingType,
                signature: response?.signature,
                id: this.messageIds.pop()
            };
            this.notifyListeners(session.pairingTopic, signPayloadResponse);
            if (this.session && this.messageIds.length) {
                this.checkWalletReadiness(this.session.pairingTopic);
            }
        })
            .catch(async () => {
            const errorResponse = {
                type: BeaconMessageType.Error,
                id: this.messageIds.pop(),
                errorType: BeaconErrorType.ABORTED_ERROR
            };
            this.notifyListeners(session.pairingTopic, errorResponse);
            if (this.session && this.messageIds.length) {
                this.checkWalletReadiness(this.session.pairingTopic);
            }
        });
    }
    /**
     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
     * @error MissingRequiredScope is thrown if permission to send operation was not granted
     */
    async sendOperations(operationRequest) {
        const signClient = await this.getSignClient();
        const session = this.getSession();
        if (!this.getPermittedMethods().includes(PermissionScopeMethods.OPERATION_REQUEST)) {
            throw new MissingRequiredScope(PermissionScopeMethods.OPERATION_REQUEST);
        }
        const network = this.getActiveNetwork();
        const account = await this.getPKH();
        this.validateNetworkAndAccount(network, account);
        this.checkWalletReadiness(session.pairingTopic);
        signClient
            .request({
            topic: session.topic,
            chainId: `${TEZOS_PLACEHOLDER}:${network}`,
            request: {
                method: PermissionScopeMethods.OPERATION_REQUEST,
                params: {
                    account,
                    operations: operationRequest.operationDetails
                }
            }
        })
            .then((response) => {
            const sendOperationResponse = {
                type: BeaconMessageType.OperationResponse,
                transactionHash: response.operationHash ?? response.transactionHash ?? response.hash ?? '',
                id: this.messageIds.pop() ?? ''
            };
            this.notifyListeners(session.pairingTopic, sendOperationResponse);
            if (this.session && this.messageIds.length) {
                this.checkWalletReadiness(this.session.pairingTopic);
            }
        })
            .catch(async () => {
            const errorResponse = {
                type: BeaconMessageType.Error,
                id: this.messageIds.pop(),
                errorType: BeaconErrorType.ABORTED_ERROR
            };
            this.notifyListeners(session.pairingTopic, errorResponse);
            if (this.session && this.messageIds.length) {
                this.checkWalletReadiness(this.session.pairingTopic);
            }
        });
    }
    async init(forceNewConnection = false) {
        const signClient = await this.getSignClient();
        if (forceNewConnection) {
            await this.closePairings();
        }
        const sessions = signClient.session.getAll();
        if (sessions && sessions.length > 0) {
            this.session = sessions[0];
            this.setDefaultAccountAndNetwork();
            return undefined;
        }
        const { uri, topic } = await signClient.core.pairing.create();
        signClient.core.pairing.ping({ topic }).then(async () => {
            await signClient.core.pairing.activate({ topic });
            // pairings don't have peer details
            // therefore we must immediately open a session
            // to get data required in the pairing response
            try {
                const session = await this.openSession(topic);
                const pairingResponse = new ExtendedWalletConnectPairingResponse(topic, session.peer.metadata.name, session.peer.publicKey, '3', topic, session.peer.metadata.name);
                this.channelOpeningListeners.forEach((listener) => {
                    listener(pairingResponse);
                });
            }
            catch (error) {
                logger.error(error.message);
                const fun = this.eventHandlers.get("CLOSE_ALERT" /* ClientEvents.CLOSE_ALERT */);
                fun && fun();
                return;
            }
        });
        return { uri, topic };
    }
    async close() {
        await this.closePairings();
    }
    subscribeToSessionEvents(signClient) {
        signClient.on('session_event', (event) => {
            if (event.params.event.name === PermissionScopeEvents.REQUEST_ACKNOWLEDGED &&
                this.messageIds.length) {
                this.acknowledgeRequest(this.messageIds[0]);
            }
        });
        signClient.on('session_update', (event) => {
            this.session = signClient.session.get(event.topic);
            this.updateActiveAccount(event.params.namespaces);
            this.notifyListenersWithPermissionResponse(this.session, {
                type: this.wcOptions.network
            });
        });
        signClient.on('session_delete', (event) => {
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.on('session_expire', (event) => {
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_delete', (event) => {
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_expire', (event) => {
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
    }
    async acknowledgeRequest(id) {
        const session = this.getSession();
        const acknowledgeResponse = {
            type: BeaconMessageType.Acknowledge,
            id
        };
        this.notifyListeners(session.pairingTopic, acknowledgeResponse);
    }
    async updateActiveAccount(namespaces) {
        try {
            const accounts = this.getTezosNamespace(namespaces).accounts;
            if (accounts.length === 1) {
                const [_namespace, chainId, addressOrPbk] = accounts[0].split(':', 3);
                const session = this.getSession();
                let publicKey;
                this.activeNetwork = chainId;
                if (addressOrPbk.startsWith('edpk')) {
                    publicKey = addressOrPbk;
                    this.activeAccount = await getAddressFromPublicKey(publicKey);
                }
                else {
                    this.activeAccount = addressOrPbk;
                    const result = await this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${chainId}`);
                    publicKey = result?.find(({ address: _address }) => addressOrPbk === _address)?.pubkey;
                }
                if (!publicKey) {
                    throw new Error('Public key for the new account not provided');
                }
                this.notifyListeners(session.pairingTopic, {
                    id: await generateGUID(),
                    type: BeaconMessageType.ChangeAccountRequest,
                    publicKey,
                    network: { type: chainId },
                    scopes: [PermissionScope.SIGN, PermissionScope.OPERATION_REQUEST],
                    walletType: 'implicit'
                });
            }
        }
        catch { }
    }
    async disconnect(signClient, trigger) {
        let session;
        if (trigger.type === 'session') {
            session = await this.onSessionClosed(signClient, trigger.topic);
        }
        if (trigger.type === 'pairing') {
            session = await this.onPairingClosed(signClient, trigger.topic);
        }
        if (!this.activeAccount) {
            const fun = this.eventHandlers.get("RESET_STATE" /* ClientEvents.RESET_STATE */);
            fun && fun();
        }
        if (!session) {
            return;
        }
        this.notifyListeners(session.pairingTopic, {
            id: await generateGUID(),
            type: BeaconMessageType.Disconnect
        });
        this.clearState();
    }
    async onPairingClosed(signClient, pairingTopic) {
        const session = this.session?.pairingTopic === pairingTopic
            ? this.session
            : signClient.session
                .getAll()
                .find((session) => session.pairingTopic === pairingTopic);
        if (!session) {
            return undefined;
        }
        try {
            await signClient.disconnect({
                topic: session.topic,
                reason: {
                    code: -1,
                    message: 'Pairing deleted'
                }
            });
        }
        catch (error) {
            // If the session was already closed, `disconnect` will throw an error.
            logger.warn(error);
        }
        return session;
    }
    async onSessionClosed(signClient, sessionTopic) {
        if (!this.session || this.session.topic !== sessionTopic) {
            return undefined;
        }
        try {
            await signClient.core.pairing.disconnect({ topic: this.session.pairingTopic });
        }
        catch (error) {
            // If the pairing was already closed, `disconnect` will throw an error.
            logger.warn(error.message);
        }
        return this.session;
    }
    async getPairingRequestInfo() {
        let _uri = '', _topic = '';
        try {
            const { uri, topic } = (await this.init(true)) ?? { uri: '', topic: '' };
            _uri = uri;
            _topic = topic;
        }
        catch (error) {
            console.warn(error.message);
        }
        return new ExtendedWalletConnectPairingRequest(_topic, 'WalletConnect', await generateGUID(), BEACON_VERSION, await generateGUID(), _uri);
    }
    async closePairings() {
        await this.closeSessions();
        const signClient = await this.getSignClient();
        const pairings = signClient.pairing.getAll() ?? [];
        pairings.length &&
            (await Promise.allSettled(pairings.map((pairing) => signClient.core.pairing.disconnect({ topic: pairing.topic }))));
        await this.storage.resetState();
    }
    async closeSessions() {
        const signClient = await this.getSignClient();
        const sessions = signClient.session.getAll() ?? [];
        sessions.length &&
            (await Promise.allSettled(sessions.map((session) => signClient.disconnect({
                topic: session.topic,
                reason: {
                    code: 0,
                    message: 'Force new connection'
                }
            }))));
        this.clearState();
    }
    async openSession(pairingTopic) {
        const signClient = await this.getSignClient();
        const permissionScopeParams = {
            networks: [this.wcOptions.network],
            events: [],
            methods: [
                PermissionScopeMethods.GET_ACCOUNTS,
                PermissionScopeMethods.OPERATION_REQUEST,
                PermissionScopeMethods.SIGN
            ]
        };
        const optionalPermissionScopeParams = {
            networks: [this.wcOptions.network],
            events: [PermissionScopeEvents.REQUEST_ACKNOWLEDGED],
            methods: []
        };
        const connectParams = {
            requiredNamespaces: {
                [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(permissionScopeParams)
            },
            optionalNamespaces: {
                [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(optionalPermissionScopeParams)
            },
            pairingTopic: pairingTopic ?? signClient.core.pairing.getPairings()[0]?.topic
        };
        this.checkWalletReadiness(connectParams.pairingTopic);
        const { approval } = await signClient.connect(connectParams);
        try {
            const session = await approval();
            // if I have successfully opened a session and I already have one opened
            if (session?.controller !== this.session?.controller) {
                this.activeAccount && this.closeActiveSession(this.activeAccount);
                this.session = undefined; // close the previous session
            }
            // I still need this check in the event the user aborts the sync process on the wallet side
            // but there is already a connection set
            this.session = this.session ?? session;
            this.validateReceivedNamespace(permissionScopeParams, this.session.namespaces);
        }
        catch (error) {
            logger.error(error.message);
            if (this.activeListeners.size === 0) {
                const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                fun && fun('error');
            }
            else {
                const _pairingTopic = pairingTopic ?? signClient.core.pairing.getPairings()[0]?.topic;
                const errorResponse = {
                    type: BeaconMessageType.Error,
                    id: this.messageIds.pop(),
                    errorType: BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(_pairingTopic, errorResponse);
            }
        }
        if (this.session) {
            return this.session;
        }
        else {
            throw new InvalidSession('No session set.');
        }
    }
    permissionScopeParamsToNamespaces(permissionScopeParams) {
        return {
            chains: permissionScopeParams.networks.map((network) => `${TEZOS_PLACEHOLDER}:${network}`),
            methods: permissionScopeParams.methods,
            events: permissionScopeParams.events ?? []
        };
    }
    validateReceivedNamespace(scope, receivedNamespaces) {
        if (receivedNamespaces[TEZOS_PLACEHOLDER]) {
            this.validateMethods(scope.methods, receivedNamespaces[TEZOS_PLACEHOLDER].methods);
            if (scope.events) {
                this.validateEvents(scope.events, receivedNamespaces['tezos'].events);
            }
            this.validateAccounts(scope.networks, receivedNamespaces[TEZOS_PLACEHOLDER].accounts);
        }
        else {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All namespaces must be approved', getSdkError('USER_REJECTED').code, 'incomplete', 'tezos');
        }
    }
    validateMethods(requiredMethods, receivedMethods) {
        const missingMethods = [];
        requiredMethods.forEach((method) => {
            if (!receivedMethods.includes(method)) {
                missingMethods.push(method);
            }
        });
        if (missingMethods.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All methods must be approved', getSdkError('USER_REJECTED_METHODS').code, 'incomplete', missingMethods);
        }
    }
    validateEvents(requiredEvents, receivedEvents) {
        const missingEvents = [];
        requiredEvents.forEach((method) => {
            if (!receivedEvents.includes(method)) {
                missingEvents.push(method);
            }
        });
        if (missingEvents.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All events must be approved', getSdkError('USER_REJECTED_EVENTS').code, 'incomplete', missingEvents);
        }
    }
    validateAccounts(requiredNetwork, receivedAccounts) {
        if (receivedAccounts.length === 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must not be empty', getSdkError('USER_REJECTED_CHAINS').code, 'incomplete');
        }
        const receivedChains = [];
        const invalidChains = [];
        const missingChains = [];
        const invalidChainsNamespace = [];
        receivedAccounts.forEach((chain) => {
            const accountId = chain.split(':');
            if (accountId.length !== 3) {
                invalidChains.push(chain);
            }
            if (accountId[0] !== TEZOS_PLACEHOLDER) {
                invalidChainsNamespace.push(chain);
            }
            const network = accountId[1];
            if (!receivedChains.includes(network)) {
                receivedChains.push(network);
            }
        });
        if (invalidChains.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must be CAIP-10 compliant', getSdkError('USER_REJECTED_CHAINS').code, 'invalid', invalidChains);
        }
        if (invalidChainsNamespace.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must be defined in matching namespace', getSdkError('UNSUPPORTED_ACCOUNTS').code, 'invalid', invalidChainsNamespace);
        }
        requiredNetwork.forEach((network) => {
            if (!receivedChains.includes(network)) {
                missingChains.push(network);
            }
        });
        if (missingChains.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All chains must have at least one account', getSdkError('USER_REJECTED_CHAINS').code, 'incomplete', missingChains);
        }
    }
    async closeActiveSession(account) {
        try {
            this.validateNetworkAndAccount(this.getActiveNetwork(), account);
        }
        catch (error) {
            logger.error(error.message);
            return;
        }
        const session = this.getSession();
        await this.signClient?.disconnect({
            topic: session.topic,
            reason: {
                code: 0,
                message: 'Force new connection'
            }
        });
    }
    validateNetworkAndAccount(network, account) {
        if (!this.getTezosNamespace().accounts.includes(`${TEZOS_PLACEHOLDER}:${network}:${account}`)) {
            throw new InvalidNetworkOrAccount(network, account);
        }
    }
    /**
     * @description Access the active network
     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos networks in the session and none is set as the active one
     */
    getActiveNetwork() {
        if (!this.activeNetwork) {
            this.getSession();
            throw new ActiveNetworkUnspecified();
        }
        return this.activeNetwork;
    }
    setDefaultAccountAndNetwork() {
        const activeAccount = this.getAccounts();
        if (activeAccount.length) {
            this.activeAccount = activeAccount[0];
        }
        const activeNetwork = this.getNetworks();
        if (activeNetwork.length) {
            this.activeNetwork = activeNetwork[0];
        }
    }
    /**
     * @description Return all connected accounts from the active session
     * @error NotConnected if no active session
     */
    getAccounts() {
        return this.getTezosNamespace().accounts.map((account) => account.split(':')[2]);
    }
    /**
     * @description Return all networks from the namespace of the active session
     * @error NotConnected if no active session
     */
    getNetworks() {
        return this.getPermittedNetwork();
    }
    getTezosNamespace(namespaces = this.getSession().namespaces) {
        if (TEZOS_PLACEHOLDER in namespaces) {
            return namespaces[TEZOS_PLACEHOLDER];
        }
        else {
            throw new InvalidSession('Tezos not found in namespaces');
        }
    }
    getPermittedMethods() {
        return this.getTezosRequiredNamespace().methods;
    }
    getPermittedNetwork() {
        return this.getTezosRequiredNamespace().chains.map((chain) => chain.split(':')[1]);
    }
    getTezosRequiredNamespace() {
        return {
            chains: [`${TEZOS_PLACEHOLDER}:${this.wcOptions.network}`],
            events: [],
            methods: ['tezos_getAccounts', 'tezos_send', 'tezos_sign']
        };
        // if (TEZOS_PLACEHOLDER in this.getSession().requiredNamespaces) {
        //   return this.getSession().requiredNamespaces[TEZOS_PLACEHOLDER] as {
        //     chains: string[]
        //     methods: string[]
        //     events: string[]
        //   }
        // } else {
        //   throw new InvalidSession('Tezos not found in requiredNamespaces')
        // }
    }
    async notifyListeners(pairingTopic, partialResponse) {
        const response = {
            ...partialResponse,
            version: '2',
            senderId: pairingTopic
        };
        const serializer = new Serializer();
        const serialized = await serializer.serialize(response);
        this.activeListeners.forEach((listener) => {
            listener(serialized);
        });
    }
    currentSession() {
        return this.session;
    }
    async getSignClient() {
        if (this.signClient === undefined) {
            this.signClient = await SignClient.init(this.wcOptions.opts);
            this.subscribeToSessionEvents(this.signClient);
        }
        return this.signClient;
    }
    getSession() {
        if (!this.session) {
            throw new NotConnected();
        }
        return this.session;
    }
    /**
     * @description Access the public key hash of the active account
     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
     */
    async getPKH() {
        if (!this.activeAccount) {
            this.getSession();
            throw new ActiveAccountUnspecified();
        }
        return this.activeAccount;
    }
    clearState() {
        this.session = undefined;
        this.activeAccount = undefined;
        this.activeNetwork = undefined;
    }
}
//# sourceMappingURL=WalletConnectCommunicationClient.js.map