"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectCommunicationClient = exports.PermissionScopeEvents = exports.PermissionScopeMethods = void 0;
const beacon_core_1 = require("@airgap/beacon-core");
const sign_client_1 = require("@walletconnect/sign-client");
const utils_1 = require("@walletconnect/utils");
const error_1 = require("../error");
const beacon_types_1 = require("@airgap/beacon-types");
const beacon_utils_1 = require("@airgap/beacon-utils");
const TEZOS_PLACEHOLDER = 'tezos';
const logger = new beacon_core_1.Logger('WalletConnectCommunicationClient');
var PermissionScopeMethods;
(function (PermissionScopeMethods) {
    PermissionScopeMethods["GET_ACCOUNTS"] = "tezos_getAccounts";
    PermissionScopeMethods["OPERATION_REQUEST"] = "tezos_send";
    PermissionScopeMethods["SIGN"] = "tezos_sign";
})(PermissionScopeMethods || (exports.PermissionScopeMethods = PermissionScopeMethods = {}));
var PermissionScopeEvents;
(function (PermissionScopeEvents) {
    PermissionScopeEvents["CHAIN_CHANGED"] = "chainChanged";
    PermissionScopeEvents["ACCOUNTS_CHANGED"] = "accountsChanged";
    PermissionScopeEvents["REQUEST_ACKNOWLEDGED"] = "requestAcknowledged";
})(PermissionScopeEvents || (exports.PermissionScopeEvents = PermissionScopeEvents = {}));
class WalletConnectCommunicationClient extends beacon_core_1.CommunicationClient {
    constructor(wcOptions) {
        super();
        this.wcOptions = wcOptions;
        this.activeListeners = new Map();
        this.channelOpeningListeners = new Map();
        this.storage = new beacon_core_1.WCStorage();
        /**
         * this queue stores each active message id
         * [0] newest message
         * [length - 1] oldest message
         */
        this.messageIds = [];
        this.getSignClient();
    }
    static getInstance(wcOptions) {
        if (!WalletConnectCommunicationClient.instance) {
            WalletConnectCommunicationClient.instance = new WalletConnectCommunicationClient(wcOptions);
        }
        return WalletConnectCommunicationClient.instance;
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const callbackFunction = (message) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(message);
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const callbackFunction = (pairingResponse) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(pairingResponse);
            });
            this.channelOpeningListeners.set('channelOpening', callbackFunction);
        });
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            // implementation
        });
    }
    unsubscribeFromEncryptedMessage(_senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // implementation
        });
    }
    checkWalletReadiness(topic) {
        var _a;
        (_a = this.signClient) === null || _a === void 0 ? void 0 : _a.core.pairing.ping({ topic }).then(() => {
            if (this.messageIds.length) {
                this.acknowledgeRequest(this.messageIds[0]);
            }
            else {
                const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                fun && fun('pending');
            }
        }).catch((error) => logger.error(error.message));
    }
    sendMessage(_message, _peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializer = new beacon_core_1.Serializer();
            const message = (yield serializer.deserialize(_message));
            if (!message) {
                return;
            }
            this.messageIds.unshift(message.id);
            switch (message.type) {
                case beacon_types_1.BeaconMessageType.PermissionRequest:
                    this.requestPermissions(message);
                    break;
                case beacon_types_1.BeaconMessageType.OperationRequest:
                    this.sendOperations(message);
                    break;
                case beacon_types_1.BeaconMessageType.SignPayloadRequest:
                    this.signPayload(message);
                    break;
                default:
                    return;
            }
        });
    }
    fetchAccounts(topic, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            return signClient.request({
                topic: topic,
                chainId: chainId,
                request: {
                    method: PermissionScopeMethods.GET_ACCOUNTS,
                    params: {}
                }
            });
        });
    }
    notifyListenersWithPermissionResponse(session, network) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            let publicKey;
            if (((_a = session.sessionProperties) === null || _a === void 0 ? void 0 : _a.pubkey) &&
                ((_b = session.sessionProperties) === null || _b === void 0 ? void 0 : _b.algo) &&
                ((_c = session.sessionProperties) === null || _c === void 0 ? void 0 : _c.address)) {
                publicKey = (_d = session.sessionProperties) === null || _d === void 0 ? void 0 : _d.pubkey;
                logger.log('[requestPermissions]: Have pubkey in sessionProperties, skipping "get_accounts" call', session.sessionProperties);
            }
            else {
                const accounts = this.getTezosNamespace(session.namespaces).accounts;
                const addressOrPbk = accounts[0].split(':', 3)[2];
                if (addressOrPbk.startsWith('edpk')) {
                    publicKey = addressOrPbk;
                }
                else {
                    if (network.type !== this.wcOptions.network) {
                        throw new Error('Network in permission request is not the same as preferred network!');
                    }
                    const result = yield this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${network.type}`);
                    if (!result || result.length < 1) {
                        throw new Error('No account shared by wallet');
                    }
                    if (result.some((account) => !account.pubkey)) {
                        throw new Error('Public Key in `tezos_getAccounts` is empty!');
                    }
                    publicKey = (_e = result[0]) === null || _e === void 0 ? void 0 : _e.pubkey;
                }
            }
            if (!publicKey) {
                throw new Error('Public Key in `tezos_getAccounts` is empty!');
            }
            const permissionResponse = {
                type: beacon_types_1.BeaconMessageType.PermissionResponse,
                appMetadata: {
                    senderId: session.pairingTopic,
                    name: session.peer.metadata.name,
                    icon: session.peer.metadata.icons[0]
                },
                publicKey,
                network,
                scopes: [beacon_types_1.PermissionScope.SIGN, beacon_types_1.PermissionScope.OPERATION_REQUEST],
                id: (_f = this.messageIds.pop()) !== null && _f !== void 0 ? _f : '',
                walletType: 'implicit'
            };
            this.notifyListeners(session.pairingTopic, permissionResponse);
        });
    }
    requestPermissions(message) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('#### Requesting permissions');
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.GET_ACCOUNTS)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.GET_ACCOUNTS);
            }
            if (this.activeAccount) {
                try {
                    yield this.openSession();
                }
                catch (error) {
                    logger.error(error.message);
                    return;
                }
            }
            this.setDefaultAccountAndNetwork();
            this.notifyListenersWithPermissionResponse(this.getSession(), message.network);
        });
    }
    /**
     * @description Once the session is establish, send payload to be approved and signed by the wallet.
     * @error MissingRequiredScope is thrown if permission to sign payload was not granted
     */
    signPayload(signPayloadRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.SIGN)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.SIGN);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getPKH();
            this.validateNetworkAndAccount(network, account);
            this.checkWalletReadiness(session.pairingTopic);
            // TODO: Type
            signClient
                .request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.SIGN,
                    params: {
                        account: account,
                        payload: signPayloadRequest.payload
                    }
                }
            })
                .then((response) => {
                const signPayloadResponse = {
                    type: beacon_types_1.BeaconMessageType.SignPayloadResponse,
                    signingType: signPayloadRequest.signingType,
                    signature: response === null || response === void 0 ? void 0 : response.signature,
                    id: this.messageIds.pop()
                };
                this.notifyListeners(session.pairingTopic, signPayloadResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.session.pairingTopic);
                }
            })
                .catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: beacon_types_1.BeaconMessageType.Error,
                    id: this.messageIds.pop(),
                    errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(session.pairingTopic, errorResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.session.pairingTopic);
                }
            }));
        });
    }
    /**
     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
     * @error MissingRequiredScope is thrown if permission to send operation was not granted
     */
    sendOperations(operationRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.OPERATION_REQUEST)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.OPERATION_REQUEST);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getPKH();
            this.validateNetworkAndAccount(network, account);
            this.checkWalletReadiness(session.pairingTopic);
            signClient
                .request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.OPERATION_REQUEST,
                    params: {
                        account,
                        operations: operationRequest.operationDetails
                    }
                }
            })
                .then((response) => {
                var _a, _b, _c, _d;
                const sendOperationResponse = {
                    type: beacon_types_1.BeaconMessageType.OperationResponse,
                    transactionHash: (_c = (_b = (_a = response.operationHash) !== null && _a !== void 0 ? _a : response.transactionHash) !== null && _b !== void 0 ? _b : response.hash) !== null && _c !== void 0 ? _c : '',
                    id: (_d = this.messageIds.pop()) !== null && _d !== void 0 ? _d : ''
                };
                this.notifyListeners(session.pairingTopic, sendOperationResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.session.pairingTopic);
                }
            })
                .catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: beacon_types_1.BeaconMessageType.Error,
                    id: this.messageIds.pop(),
                    errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(session.pairingTopic, errorResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.session.pairingTopic);
                }
            }));
        });
    }
    init(forceNewConnection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            if (forceNewConnection) {
                yield this.closePairings();
            }
            const sessions = signClient.session.getAll();
            if (sessions && sessions.length > 0) {
                this.session = sessions[0];
                this.setDefaultAccountAndNetwork();
                return undefined;
            }
            const { uri, topic } = yield signClient.core.pairing.create();
            signClient.core.pairing.ping({ topic }).then(() => __awaiter(this, void 0, void 0, function* () {
                yield signClient.core.pairing.activate({ topic });
                // pairings don't have peer details
                // therefore we must immediately open a session
                // to get data required in the pairing response
                try {
                    const session = yield this.openSession(topic);
                    const pairingResponse = new beacon_types_1.ExtendedWalletConnectPairingResponse(topic, session.peer.metadata.name, session.peer.publicKey, '3', topic, session.peer.metadata.name);
                    this.channelOpeningListeners.forEach((listener) => {
                        listener(pairingResponse);
                    });
                }
                catch (error) {
                    logger.error(error.message);
                    const fun = this.eventHandlers.get("CLOSE_ALERT" /* ClientEvents.CLOSE_ALERT */);
                    fun && fun();
                    return;
                }
            }));
            return { uri, topic };
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.closePairings();
        });
    }
    subscribeToSessionEvents(signClient) {
        signClient.on('session_event', (event) => {
            if (event.params.event.name === PermissionScopeEvents.REQUEST_ACKNOWLEDGED &&
                this.messageIds.length) {
                this.acknowledgeRequest(this.messageIds[0]);
            }
        });
        signClient.on('session_update', (event) => {
            this.session = signClient.session.get(event.topic);
            this.updateActiveAccount(event.params.namespaces);
            this.notifyListenersWithPermissionResponse(this.session, {
                type: this.wcOptions.network
            });
        });
        signClient.on('session_delete', (event) => {
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.on('session_expire', (event) => {
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_delete', (event) => {
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_expire', (event) => {
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
    }
    acknowledgeRequest(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = this.getSession();
            const acknowledgeResponse = {
                type: beacon_types_1.BeaconMessageType.Acknowledge,
                id
            };
            this.notifyListeners(session.pairingTopic, acknowledgeResponse);
        });
    }
    updateActiveAccount(namespaces) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const accounts = this.getTezosNamespace(namespaces).accounts;
                if (accounts.length === 1) {
                    const [_namespace, chainId, addressOrPbk] = accounts[0].split(':', 3);
                    const session = this.getSession();
                    let publicKey;
                    this.activeNetwork = chainId;
                    if (addressOrPbk.startsWith('edpk')) {
                        publicKey = addressOrPbk;
                        this.activeAccount = yield (0, beacon_utils_1.getAddressFromPublicKey)(publicKey);
                    }
                    else {
                        this.activeAccount = addressOrPbk;
                        const result = yield this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${chainId}`);
                        publicKey = (_a = result === null || result === void 0 ? void 0 : result.find(({ address: _address }) => addressOrPbk === _address)) === null || _a === void 0 ? void 0 : _a.pubkey;
                    }
                    if (!publicKey) {
                        throw new Error('Public key for the new account not provided');
                    }
                    this.notifyListeners(session.pairingTopic, {
                        id: yield (0, beacon_utils_1.generateGUID)(),
                        type: beacon_types_1.BeaconMessageType.ChangeAccountRequest,
                        publicKey,
                        network: { type: chainId },
                        scopes: [beacon_types_1.PermissionScope.SIGN, beacon_types_1.PermissionScope.OPERATION_REQUEST],
                        walletType: 'implicit'
                    });
                }
            }
            catch (_b) { }
        });
    }
    disconnect(signClient, trigger) {
        return __awaiter(this, void 0, void 0, function* () {
            let session;
            if (trigger.type === 'session') {
                session = yield this.onSessionClosed(signClient, trigger.topic);
            }
            if (trigger.type === 'pairing') {
                session = yield this.onPairingClosed(signClient, trigger.topic);
            }
            if (!this.activeAccount) {
                const fun = this.eventHandlers.get("RESET_STATE" /* ClientEvents.RESET_STATE */);
                fun && fun();
            }
            if (!session) {
                return;
            }
            this.notifyListeners(session.pairingTopic, {
                id: yield (0, beacon_utils_1.generateGUID)(),
                type: beacon_types_1.BeaconMessageType.Disconnect
            });
            this.clearState();
        });
    }
    onPairingClosed(signClient, pairingTopic) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const session = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.pairingTopic) === pairingTopic
                ? this.session
                : signClient.session
                    .getAll()
                    .find((session) => session.pairingTopic === pairingTopic);
            if (!session) {
                return undefined;
            }
            try {
                yield signClient.disconnect({
                    topic: session.topic,
                    reason: {
                        code: -1,
                        message: 'Pairing deleted'
                    }
                });
            }
            catch (error) {
                // If the session was already closed, `disconnect` will throw an error.
                logger.warn(error);
            }
            return session;
        });
    }
    onSessionClosed(signClient, sessionTopic) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session || this.session.topic !== sessionTopic) {
                return undefined;
            }
            try {
                yield signClient.core.pairing.disconnect({ topic: this.session.pairingTopic });
            }
            catch (error) {
                // If the pairing was already closed, `disconnect` will throw an error.
                logger.warn(error.message);
            }
            return this.session;
        });
    }
    getPairingRequestInfo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let _uri = '', _topic = '';
            try {
                const { uri, topic } = (_a = (yield this.init(true))) !== null && _a !== void 0 ? _a : { uri: '', topic: '' };
                _uri = uri;
                _topic = topic;
            }
            catch (error) {
                console.warn(error.message);
            }
            return new beacon_types_1.ExtendedWalletConnectPairingRequest(_topic, 'WalletConnect', yield (0, beacon_utils_1.generateGUID)(), beacon_core_1.BEACON_VERSION, yield (0, beacon_utils_1.generateGUID)(), _uri);
        });
    }
    closePairings() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.closeSessions();
            const signClient = yield this.getSignClient();
            const pairings = (_a = signClient.pairing.getAll()) !== null && _a !== void 0 ? _a : [];
            pairings.length &&
                (yield Promise.allSettled(pairings.map((pairing) => signClient.core.pairing.disconnect({ topic: pairing.topic }))));
            yield this.storage.resetState();
        });
    }
    closeSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            const sessions = (_a = signClient.session.getAll()) !== null && _a !== void 0 ? _a : [];
            sessions.length &&
                (yield Promise.allSettled(sessions.map((session) => signClient.disconnect({
                    topic: session.topic,
                    reason: {
                        code: 0,
                        message: 'Force new connection'
                    }
                }))));
            this.clearState();
        });
    }
    openSession(pairingTopic) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            const permissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [],
                methods: [
                    PermissionScopeMethods.GET_ACCOUNTS,
                    PermissionScopeMethods.OPERATION_REQUEST,
                    PermissionScopeMethods.SIGN
                ]
            };
            const optionalPermissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [PermissionScopeEvents.REQUEST_ACKNOWLEDGED],
                methods: []
            };
            const connectParams = {
                requiredNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(permissionScopeParams)
                },
                optionalNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(optionalPermissionScopeParams)
                },
                pairingTopic: pairingTopic !== null && pairingTopic !== void 0 ? pairingTopic : (_a = signClient.core.pairing.getPairings()[0]) === null || _a === void 0 ? void 0 : _a.topic
            };
            this.checkWalletReadiness(connectParams.pairingTopic);
            const { approval } = yield signClient.connect(connectParams);
            try {
                const session = yield approval();
                // if I have successfully opened a session and I already have one opened
                if ((session === null || session === void 0 ? void 0 : session.controller) !== ((_b = this.session) === null || _b === void 0 ? void 0 : _b.controller)) {
                    this.activeAccount && this.closeActiveSession(this.activeAccount);
                    this.session = undefined; // close the previous session
                }
                // I still need this check in the event the user aborts the sync process on the wallet side
                // but there is already a connection set
                this.session = (_c = this.session) !== null && _c !== void 0 ? _c : session;
                this.validateReceivedNamespace(permissionScopeParams, this.session.namespaces);
            }
            catch (error) {
                logger.error(error.message);
                if (this.activeListeners.size === 0) {
                    const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                    fun && fun('error');
                }
                else {
                    const _pairingTopic = pairingTopic !== null && pairingTopic !== void 0 ? pairingTopic : (_d = signClient.core.pairing.getPairings()[0]) === null || _d === void 0 ? void 0 : _d.topic;
                    const errorResponse = {
                        type: beacon_types_1.BeaconMessageType.Error,
                        id: this.messageIds.pop(),
                        errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                    };
                    this.notifyListeners(_pairingTopic, errorResponse);
                }
            }
            if (this.session) {
                return this.session;
            }
            else {
                throw new error_1.InvalidSession('No session set.');
            }
        });
    }
    permissionScopeParamsToNamespaces(permissionScopeParams) {
        var _a;
        return {
            chains: permissionScopeParams.networks.map((network) => `${TEZOS_PLACEHOLDER}:${network}`),
            methods: permissionScopeParams.methods,
            events: (_a = permissionScopeParams.events) !== null && _a !== void 0 ? _a : []
        };
    }
    validateReceivedNamespace(scope, receivedNamespaces) {
        if (receivedNamespaces[TEZOS_PLACEHOLDER]) {
            this.validateMethods(scope.methods, receivedNamespaces[TEZOS_PLACEHOLDER].methods);
            if (scope.events) {
                this.validateEvents(scope.events, receivedNamespaces['tezos'].events);
            }
            this.validateAccounts(scope.networks, receivedNamespaces[TEZOS_PLACEHOLDER].accounts);
        }
        else {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All namespaces must be approved', (0, utils_1.getSdkError)('USER_REJECTED').code, 'incomplete', 'tezos');
        }
    }
    validateMethods(requiredMethods, receivedMethods) {
        const missingMethods = [];
        requiredMethods.forEach((method) => {
            if (!receivedMethods.includes(method)) {
                missingMethods.push(method);
            }
        });
        if (missingMethods.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All methods must be approved', (0, utils_1.getSdkError)('USER_REJECTED_METHODS').code, 'incomplete', missingMethods);
        }
    }
    validateEvents(requiredEvents, receivedEvents) {
        const missingEvents = [];
        requiredEvents.forEach((method) => {
            if (!receivedEvents.includes(method)) {
                missingEvents.push(method);
            }
        });
        if (missingEvents.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All events must be approved', (0, utils_1.getSdkError)('USER_REJECTED_EVENTS').code, 'incomplete', missingEvents);
        }
    }
    validateAccounts(requiredNetwork, receivedAccounts) {
        if (receivedAccounts.length === 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must not be empty', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'incomplete');
        }
        const receivedChains = [];
        const invalidChains = [];
        const missingChains = [];
        const invalidChainsNamespace = [];
        receivedAccounts.forEach((chain) => {
            const accountId = chain.split(':');
            if (accountId.length !== 3) {
                invalidChains.push(chain);
            }
            if (accountId[0] !== TEZOS_PLACEHOLDER) {
                invalidChainsNamespace.push(chain);
            }
            const network = accountId[1];
            if (!receivedChains.includes(network)) {
                receivedChains.push(network);
            }
        });
        if (invalidChains.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must be CAIP-10 compliant', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'invalid', invalidChains);
        }
        if (invalidChainsNamespace.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must be defined in matching namespace', (0, utils_1.getSdkError)('UNSUPPORTED_ACCOUNTS').code, 'invalid', invalidChainsNamespace);
        }
        requiredNetwork.forEach((network) => {
            if (!receivedChains.includes(network)) {
                missingChains.push(network);
            }
        });
        if (missingChains.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All chains must have at least one account', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'incomplete', missingChains);
        }
    }
    closeActiveSession(account) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.validateNetworkAndAccount(this.getActiveNetwork(), account);
            }
            catch (error) {
                logger.error(error.message);
                return;
            }
            const session = this.getSession();
            yield ((_a = this.signClient) === null || _a === void 0 ? void 0 : _a.disconnect({
                topic: session.topic,
                reason: {
                    code: 0,
                    message: 'Force new connection'
                }
            }));
        });
    }
    validateNetworkAndAccount(network, account) {
        if (!this.getTezosNamespace().accounts.includes(`${TEZOS_PLACEHOLDER}:${network}:${account}`)) {
            throw new error_1.InvalidNetworkOrAccount(network, account);
        }
    }
    /**
     * @description Access the active network
     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos networks in the session and none is set as the active one
     */
    getActiveNetwork() {
        if (!this.activeNetwork) {
            this.getSession();
            throw new error_1.ActiveNetworkUnspecified();
        }
        return this.activeNetwork;
    }
    setDefaultAccountAndNetwork() {
        const activeAccount = this.getAccounts();
        if (activeAccount.length) {
            this.activeAccount = activeAccount[0];
        }
        const activeNetwork = this.getNetworks();
        if (activeNetwork.length) {
            this.activeNetwork = activeNetwork[0];
        }
    }
    /**
     * @description Return all connected accounts from the active session
     * @error NotConnected if no active session
     */
    getAccounts() {
        return this.getTezosNamespace().accounts.map((account) => account.split(':')[2]);
    }
    /**
     * @description Return all networks from the namespace of the active session
     * @error NotConnected if no active session
     */
    getNetworks() {
        return this.getPermittedNetwork();
    }
    getTezosNamespace(namespaces = this.getSession().namespaces) {
        if (TEZOS_PLACEHOLDER in namespaces) {
            return namespaces[TEZOS_PLACEHOLDER];
        }
        else {
            throw new error_1.InvalidSession('Tezos not found in namespaces');
        }
    }
    getPermittedMethods() {
        return this.getTezosRequiredNamespace().methods;
    }
    getPermittedNetwork() {
        return this.getTezosRequiredNamespace().chains.map((chain) => chain.split(':')[1]);
    }
    getTezosRequiredNamespace() {
        return {
            chains: [`${TEZOS_PLACEHOLDER}:${this.wcOptions.network}`],
            events: [],
            methods: ['tezos_getAccounts', 'tezos_send', 'tezos_sign']
        };
        // if (TEZOS_PLACEHOLDER in this.getSession().requiredNamespaces) {
        //   return this.getSession().requiredNamespaces[TEZOS_PLACEHOLDER] as {
        //     chains: string[]
        //     methods: string[]
        //     events: string[]
        //   }
        // } else {
        //   throw new InvalidSession('Tezos not found in requiredNamespaces')
        // }
    }
    notifyListeners(pairingTopic, partialResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = Object.assign(Object.assign({}, partialResponse), { version: '2', senderId: pairingTopic });
            const serializer = new beacon_core_1.Serializer();
            const serialized = yield serializer.serialize(response);
            this.activeListeners.forEach((listener) => {
                listener(serialized);
            });
        });
    }
    currentSession() {
        return this.session;
    }
    getSignClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signClient === undefined) {
                this.signClient = yield sign_client_1.SignClient.init(this.wcOptions.opts);
                this.subscribeToSessionEvents(this.signClient);
            }
            return this.signClient;
        });
    }
    getSession() {
        if (!this.session) {
            throw new error_1.NotConnected();
        }
        return this.session;
    }
    /**
     * @description Access the public key hash of the active account
     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
     */
    getPKH() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccount) {
                this.getSession();
                throw new error_1.ActiveAccountUnspecified();
            }
            return this.activeAccount;
        });
    }
    clearState() {
        this.session = undefined;
        this.activeAccount = undefined;
        this.activeNetwork = undefined;
    }
}
exports.WalletConnectCommunicationClient = WalletConnectCommunicationClient;
//# sourceMappingURL=WalletConnectCommunicationClient.js.map