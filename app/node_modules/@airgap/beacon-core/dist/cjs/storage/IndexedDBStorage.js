"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexedDBStorage = void 0;
const beacon_types_1 = require("@airgap/beacon-types");
const beacon_core_1 = require("@airgap/beacon-core");
const logger = new beacon_core_1.Logger('IndexedDBStorage');
class IndexedDBStorage extends beacon_types_1.Storage {
    constructor() {
        super(...arguments);
        this.dbName = 'WALLET_CONNECT_V2_INDEXED_DB';
        this.storeName = 'keyvaluestorage';
        this.db = null;
    }
    static doesDatabaseAndTableExist() {
        return __awaiter(this, void 0, void 0, function* () {
            const targetDatabaseName = 'WALLET_CONNECT_V2_INDEXED_DB';
            const targetTableName = 'keyvaluestorage';
            const databases = yield indexedDB.databases();
            if (!databases.some((database) => database.name === targetDatabaseName)) {
                return false; // The specified database doesn't exist
            }
            // Open the database to check if the table exists
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(targetDatabaseName);
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    if (db.objectStoreNames.contains(targetTableName)) {
                        // The table exists in the database
                        resolve(true);
                    }
                    else {
                        // The table doesn't exist in the database
                        resolve(false);
                    }
                    db.close();
                };
                request.onerror = (event) => {
                    console.error('Error opening database:', event.target.error);
                    reject(false); // Assume the table doesn't exist if there's an error opening the database
                };
            });
        });
    }
    openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = (event) => {
                this.db = event.target.result;
                // Create object store if it doesn't exist
                if (this.db && !this.db.objectStoreNames.contains(this.storeName)) {
                    this.db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                }
            };
            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve('Database opened successfully');
            };
            request.onerror = (event) => {
                reject(`Error opening database: ${event.target.error}`);
            };
        });
    }
    get(key) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readonly');
                const objectStore = transaction.objectStore(this.storeName);
                const getRequest = objectStore.get(key);
                getRequest.onsuccess = () => {
                    const result = getRequest.result;
                    resolve(result);
                };
                getRequest.onerror = (getEvent) => {
                    logger.error(`Error getting record with key ${key}:`, getEvent.target);
                    reject(getEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
    set(key, value) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const putRequest = objectStore.put(value, key);
                putRequest.onsuccess = () => {
                    logger.log(`Record with key ${key} updated/inserted successfully`);
                    resolve();
                };
                putRequest.onerror = (putEvent) => {
                    logger.error(`Error updating/inserting record with key ${key}:`, putEvent.target);
                    reject(putEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
    delete(key) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const deleteRequest = objectStore.delete(key);
                deleteRequest.onsuccess = () => {
                    logger.log(`Record with key ${key} deleted successfully`);
                    resolve();
                };
                deleteRequest.onerror = (deleteEvent) => {
                    logger.error(`Error deleting record with key ${key}:`, deleteEvent.target.error);
                    reject(deleteEvent.target.error);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target.error);
                reject(event.target.error);
            };
        });
    }
    subscribeToStorageChanged(callback) {
        logger.debug('subscriveToStorageEvent', callback);
        throw new Error('Method not implemented.');
    }
    getPrefixedKey(key) {
        logger.debug('getPrefixedKey', key);
        throw new Error('Method not implemented.');
    }
    clearTable() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const clearRequest = objectStore.clear();
                clearRequest.onsuccess = () => {
                    logger.log(`All entries in ${this.storeName} cleared successfully`);
                    resolve();
                };
                clearRequest.onerror = (clearEvent) => {
                    logger.error(`Error clearing entries in ${this.storeName}:`, clearEvent.target);
                    reject(clearEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
}
exports.IndexedDBStorage = IndexedDBStorage;
//# sourceMappingURL=IndexedDBStorage.js.map