"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBasedClient = void 0;
const constants_1 = require("../../constants");
const beacon_utils_1 = require("@airgap/beacon-utils");
const CommunicationClient_1 = require("./CommunicationClient");
const beacon_types_1 = require("@airgap/beacon-types");
/**
 * @internalapi
 *
 *
 */
class MessageBasedClient extends CommunicationClient_1.CommunicationClient {
    constructor(name, keyPair) {
        super(keyPair);
        this.name = name;
        this.init().catch(console.error);
    }
    /**
     * start the client and make sure all dependencies are ready
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.resolve();
        });
    }
    /**
     * Get the pairing request information. This will be shared with the peer during the connection setup
     */
    getPairingRequestInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return new beacon_types_1.PostMessagePairingRequest(yield (0, beacon_utils_1.generateGUID)(), this.name, yield this.getPublicKey(), constants_1.BEACON_VERSION);
        });
    }
    /**
     * Get the pairing response information. This will be shared with the peer during the connection setup
     */
    getPairingResponseInfo(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return new beacon_types_1.PostMessagePairingResponse(request.id, this.name, yield this.getPublicKey(), request.version);
        });
    }
    /**
     * Unsubscribe from encrypted messages from a specific peer
     *
     * @param senderPublicKey
     */
    unsubscribeFromEncryptedMessage(senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const listener = this.activeListeners.get(senderPublicKey);
            if (!listener) {
                return;
            }
            this.activeListeners.delete(senderPublicKey);
        });
    }
    /**
     * Unsubscribe from all encrypted messages
     */
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            this.activeListeners.clear();
        });
    }
    /**
     * Decrypt a message from a specific peer
     *
     * @param senderPublicKey
     * @param payload
     */
    decryptMessage(senderPublicKey, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedKey = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair);
            const hexPayload = Buffer.from(payload, 'hex');
            if (hexPayload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES) {
                try {
                    return yield (0, beacon_utils_1.decryptCryptoboxPayload)(hexPayload, sharedKey.receive);
                }
                catch (decryptionError) {
                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                }
            }
            throw new Error('Could not decrypt message');
        });
    }
    /**
     * Encrypt a message for a specific publicKey (receiver)
     *
     * @param recipientPublicKey
     * @param message
     */
    encryptMessage(recipientPublicKey, message) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedKey = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair);
            return (0, beacon_utils_1.encryptCryptoboxPayload)(message, sharedKey.send);
        });
    }
}
exports.MessageBasedClient = MessageBasedClient;
//# sourceMappingURL=MessageBasedClient.js.map