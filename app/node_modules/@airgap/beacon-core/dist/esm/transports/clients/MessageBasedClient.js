import { BEACON_VERSION } from '../../constants';
import { decryptCryptoboxPayload, encryptCryptoboxPayload, generateGUID, secretbox_NONCEBYTES, secretbox_MACBYTES } from '@airgap/beacon-utils';
import { CommunicationClient } from './CommunicationClient';
import { PostMessagePairingRequest, PostMessagePairingResponse } from '@airgap/beacon-types';
/**
 * @internalapi
 *
 *
 */
export class MessageBasedClient extends CommunicationClient {
    name;
    constructor(name, keyPair) {
        super(keyPair);
        this.name = name;
        this.init().catch(console.error);
    }
    /**
     * start the client and make sure all dependencies are ready
     */
    async start() {
        await Promise.resolve();
    }
    /**
     * Get the pairing request information. This will be shared with the peer during the connection setup
     */
    async getPairingRequestInfo() {
        return new PostMessagePairingRequest(await generateGUID(), this.name, await this.getPublicKey(), BEACON_VERSION);
    }
    /**
     * Get the pairing response information. This will be shared with the peer during the connection setup
     */
    async getPairingResponseInfo(request) {
        return new PostMessagePairingResponse(request.id, this.name, await this.getPublicKey(), request.version);
    }
    /**
     * Unsubscribe from encrypted messages from a specific peer
     *
     * @param senderPublicKey
     */
    async unsubscribeFromEncryptedMessage(senderPublicKey) {
        const listener = this.activeListeners.get(senderPublicKey);
        if (!listener) {
            return;
        }
        this.activeListeners.delete(senderPublicKey);
    }
    /**
     * Unsubscribe from all encrypted messages
     */
    async unsubscribeFromEncryptedMessages() {
        this.activeListeners.clear();
    }
    /**
     * Decrypt a message from a specific peer
     *
     * @param senderPublicKey
     * @param payload
     */
    async decryptMessage(senderPublicKey, payload) {
        const sharedKey = await this.createCryptoBoxServer(senderPublicKey, this.keyPair);
        const hexPayload = Buffer.from(payload, 'hex');
        if (hexPayload.length >= secretbox_NONCEBYTES + secretbox_MACBYTES) {
            try {
                return await decryptCryptoboxPayload(hexPayload, sharedKey.receive);
            }
            catch (decryptionError) {
                /* NO-OP. We try to decode every message, but some might not be addressed to us. */
            }
        }
        throw new Error('Could not decrypt message');
    }
    /**
     * Encrypt a message for a specific publicKey (receiver)
     *
     * @param recipientPublicKey
     * @param message
     */
    async encryptMessage(recipientPublicKey, message) {
        const sharedKey = await this.createCryptoBoxClient(recipientPublicKey, this.keyPair);
        return encryptCryptoboxPayload(message, sharedKey.send);
    }
}
//# sourceMappingURL=MessageBasedClient.js.map