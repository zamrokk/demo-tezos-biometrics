import { Logger } from '../utils/Logger';
import { TransportType, TransportStatus } from '@airgap/beacon-types';
const logger = new Logger('Transport');
/**
 * @internalapi
 *
 *
 */
export class Transport {
    /**
     * The type of the transport
     */
    type = TransportType.POST_MESSAGE;
    /**
     * The name of the app
     */
    name;
    /**
     * The status of the transport
     */
    _isConnected = TransportStatus.NOT_CONNECTED;
    peerManager;
    /**
     * The client handling the encryption/decryption of messages
     */
    client;
    /**
     * The listener that will be invoked when a new peer is connected
     */
    newPeerListener;
    setEventHandler(event, fun) {
        this.client.eventHandlers.set(event, fun);
    }
    /**
     * The listeners that will be notified when new messages are coming in
     */
    listeners = [];
    /**
     * Return the status of the connection
     */
    get connectionStatus() {
        return this._isConnected;
    }
    constructor(name, client, peerManager) {
        this.name = name;
        this.client = client;
        this.peerManager = peerManager;
    }
    /**
     * Returns a promise that resolves to true if the transport is available, false if it is not
     */
    static async isAvailable() {
        return Promise.resolve(false);
    }
    /**
     * Connect the transport
     */
    async connect() {
        logger.log('connect');
        this._isConnected = TransportStatus.CONNECTED;
        return;
    }
    /**
     * Disconnect the transport
     */
    async disconnect() {
        logger.log('disconnect');
        this._isConnected = TransportStatus.NOT_CONNECTED;
        return;
    }
    /**
     * Send a message through the transport
     *
     * @param message The message to send
     * @param recipient The recipient of the message
     */
    async send(message, peer) {
        if (peer) {
            return this.client.sendMessage(message, peer);
        }
        else {
            const knownPeers = await this.getPeers();
            // A broadcast request has to be sent everywhere.
            const promises = knownPeers.map((peerEl) => this.client.sendMessage(message, peerEl));
            return (await Promise.all(promises))[0];
        }
    }
    /**
     * Add a listener to be called when a new message is received
     *
     * @param listener The listener that will be registered
     */
    async addListener(listener) {
        logger.debug('addListener');
        this.listeners.push(listener);
        return;
    }
    /**
     * Remove a listener
     *
     * @param listener
     */
    async removeListener(listener) {
        logger.log('removeListener');
        this.listeners = this.listeners.filter((element) => element !== listener);
        return;
    }
    async getPeers() {
        return this.peerManager.getPeers(); // TODO: Fix type
    }
    async addPeer(newPeer, _sendPairingResponse = true) {
        logger.log('addPeer', 'adding peer', newPeer);
        await this.peerManager.addPeer(newPeer); // TODO: Fix type
        await this.listen(newPeer.publicKey);
    }
    async removePeer(peerToBeRemoved) {
        logger.log('removePeer', 'removing peer', peerToBeRemoved);
        await this.peerManager.removePeer(peerToBeRemoved.publicKey);
        if (this.client) {
            await this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);
        }
    }
    async removeAllPeers() {
        logger.log('removeAllPeers');
        await this.peerManager.removeAllPeers();
        if (this.client) {
            await this.client.unsubscribeFromEncryptedMessages();
        }
    }
    /**
     * Notify the listeners when a new message comes in
     *
     * @param message Message
     * @param connectionInfo Context info about the connection
     */
    async notifyListeners(message, connectionInfo) {
        if (this.listeners.length === 0) {
            logger.warn('notifyListeners', '0 listeners notified!', this);
        }
        else {
            logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);
        }
        this.listeners.forEach((listener) => {
            listener(message, connectionInfo);
        });
        return;
    }
}
//# sourceMappingURL=Transport.js.map