import { Storage } from '@airgap/beacon-types';
import { Logger } from '@airgap/beacon-core';
const logger = new Logger('IndexedDBStorage');
export class IndexedDBStorage extends Storage {
    dbName = 'WALLET_CONNECT_V2_INDEXED_DB';
    storeName = 'keyvaluestorage';
    db = null;
    static async doesDatabaseAndTableExist() {
        const targetDatabaseName = 'WALLET_CONNECT_V2_INDEXED_DB';
        const targetTableName = 'keyvaluestorage';
        const databases = await indexedDB.databases();
        if (!databases.some((database) => database.name === targetDatabaseName)) {
            return false; // The specified database doesn't exist
        }
        // Open the database to check if the table exists
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(targetDatabaseName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                if (db.objectStoreNames.contains(targetTableName)) {
                    // The table exists in the database
                    resolve(true);
                }
                else {
                    // The table doesn't exist in the database
                    resolve(false);
                }
                db.close();
            };
            request.onerror = (event) => {
                console.error('Error opening database:', event.target.error);
                reject(false); // Assume the table doesn't exist if there's an error opening the database
            };
        });
    }
    openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = (event) => {
                this.db = event.target.result;
                // Create object store if it doesn't exist
                if (this.db && !this.db.objectStoreNames.contains(this.storeName)) {
                    this.db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                }
            };
            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve('Database opened successfully');
            };
            request.onerror = (event) => {
                reject(`Error opening database: ${event.target.error}`);
            };
        });
    }
    get(key) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readonly');
                const objectStore = transaction.objectStore(this.storeName);
                const getRequest = objectStore.get(key);
                getRequest.onsuccess = () => {
                    const result = getRequest.result;
                    resolve(result);
                };
                getRequest.onerror = (getEvent) => {
                    logger.error(`Error getting record with key ${key}:`, getEvent.target);
                    reject(getEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
    set(key, value) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const putRequest = objectStore.put(value, key);
                putRequest.onsuccess = () => {
                    logger.log(`Record with key ${key} updated/inserted successfully`);
                    resolve();
                };
                putRequest.onerror = (putEvent) => {
                    logger.error(`Error updating/inserting record with key ${key}:`, putEvent.target);
                    reject(putEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
    delete(key) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const deleteRequest = objectStore.delete(key);
                deleteRequest.onsuccess = () => {
                    logger.log(`Record with key ${key} deleted successfully`);
                    resolve();
                };
                deleteRequest.onerror = (deleteEvent) => {
                    logger.error(`Error deleting record with key ${key}:`, deleteEvent.target.error);
                    reject(deleteEvent.target.error);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target.error);
                reject(event.target.error);
            };
        });
    }
    subscribeToStorageChanged(callback) {
        logger.debug('subscriveToStorageEvent', callback);
        throw new Error('Method not implemented.');
    }
    getPrefixedKey(key) {
        logger.debug('getPrefixedKey', key);
        throw new Error('Method not implemented.');
    }
    clearTable() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(this.storeName, 'readwrite');
                const objectStore = transaction.objectStore(this.storeName);
                const clearRequest = objectStore.clear();
                clearRequest.onsuccess = () => {
                    logger.log(`All entries in ${this.storeName} cleared successfully`);
                    resolve();
                };
                clearRequest.onerror = (clearEvent) => {
                    logger.error(`Error clearing entries in ${this.storeName}:`, clearEvent.target);
                    reject(clearEvent.target);
                };
            };
            request.onerror = (event) => {
                logger.error('Error opening database:', event.target);
                reject(event.target);
            };
        });
    }
}
//# sourceMappingURL=IndexedDBStorage.js.map