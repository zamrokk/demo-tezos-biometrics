import { ExposedPromise } from '@airgap/beacon-utils';
import { getKeypairFromSeed, toHex, generateGUID } from '@airgap/beacon-utils';
import { StorageKey } from '@airgap/beacon-types';
import { SDK_VERSION } from '../../constants';
import { windowRef } from '../../MockWindow';
import { MockAnalytics } from '../../MockAnalytics';
/**
 * @internalapi
 *
 * The beacon client is an abstract client that handles everything that is shared between all other clients.
 * Specifically, it handles managing the beaconId and and the local keypair.
 */
export class BeaconClient {
    /**
     * The name of the client
     */
    name;
    /**
     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet
     */
    iconUrl;
    /**
     * The URL of the dApp.
     */
    appUrl;
    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).
     * This is used inside a message to specify the sender, for example.
     */
    _beaconId = new ExposedPromise();
    get beaconId() {
        return this._beaconId.promise;
    }
    storage;
    analytics;
    /**
     * The local keypair that is used for the communication encryption
     */
    _keyPair = new ExposedPromise();
    get keyPair() {
        return this._keyPair.promise;
    }
    constructor(config) {
        if (!config.name) {
            throw new Error('Name not set');
        }
        if (!config.storage) {
            throw new Error('Storage not set');
        }
        this.name = config.name;
        this.iconUrl = config.iconUrl;
        this.appUrl = config.appUrl ?? windowRef.location.origin;
        this.storage = config.storage;
        this.analytics = config.analytics ?? new MockAnalytics();
        // TODO: This is a temporary "workaround" to prevent users from creating multiple Client instances
        if (windowRef.beaconCreatedClientInstance) {
            console.error('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');
        }
        else {
            ;
            windowRef.beaconCreatedClientInstance = true;
        }
        this.initSDK().catch(console.error);
    }
    /**
     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.
     */
    async destroy() {
        await this.removeBeaconEntriesFromStorage();
        windowRef.beaconCreatedClientInstance = false;
    }
    /**
     * This method initializes the SDK by setting some values in the storage and generating a keypair.
     */
    async initSDK() {
        this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);
        this.loadOrCreateBeaconSecret().catch(console.error);
        return this.keyPair.then((keyPair) => {
            this._beaconId.resolve(toHex(keyPair.publicKey));
        });
    }
    /**
     * Removes all beacon values from the storage.
     */
    async removeBeaconEntriesFromStorage() {
        const allKeys = Object.values(StorageKey);
        await Promise.all(allKeys.map((key) => this.storage.delete(key)));
    }
    /**
     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.
     */
    async loadOrCreateBeaconSecret() {
        const storageValue = await this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);
        if (storageValue && typeof storageValue === 'string') {
            this._keyPair.resolve(await getKeypairFromSeed(storageValue));
        }
        else {
            const key = await generateGUID();
            await this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);
            this._keyPair.resolve(await getKeypairFromSeed(key));
        }
    }
}
//# sourceMappingURL=BeaconClient.js.map