import { Logger, Transport, PeerManager } from '@airgap/beacon-core';
import { TransportStatus, TransportType, Origin } from '@airgap/beacon-types';
import { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';
const logger = new Logger('P2PTransport');
/**
 * @internalapi
 *
 *
 */
export class P2PTransport extends Transport {
    type = TransportType.P2P;
    constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {
        super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));
    }
    static async isAvailable() {
        return Promise.resolve(true);
    }
    async connect() {
        if (this._isConnected !== TransportStatus.NOT_CONNECTED) {
            return;
        }
        logger.log('connect');
        this._isConnected = TransportStatus.CONNECTING;
        await this.client.start();
        const knownPeers = await this.getPeers();
        if (knownPeers.length > 0) {
            logger.log('connect', `connecting to ${knownPeers.length} peers`);
            const connectionPromises = knownPeers.map(async (peer) => this.listen(peer.publicKey));
            Promise.all(connectionPromises).catch((error) => logger.error('connect', error));
        }
        await this.startOpenChannelListener();
        return super.connect();
    }
    async disconnect() {
        await this.client.stop();
        return super.disconnect();
    }
    async startOpenChannelListener() {
        //
    }
    async getPairingRequestInfo() {
        return this.client.getPairingRequestInfo();
    }
    async listen(publicKey) {
        await this.client
            .listenForEncryptedMessage(publicKey, (message) => {
            const connectionContext = {
                origin: Origin.P2P,
                id: publicKey
            };
            this.notifyListeners(message, connectionContext).catch((error) => {
                throw error;
            });
        })
            .catch((error) => {
            throw error;
        });
    }
}
//# sourceMappingURL=P2PTransport.js.map