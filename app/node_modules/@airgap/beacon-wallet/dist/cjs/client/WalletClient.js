"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClient = void 0;
const axios_1 = require("axios");
const beacon_core_1 = require("@airgap/beacon-core");
const beacon_utils_1 = require("@airgap/beacon-utils");
const beacon_types_1 = require("@airgap/beacon-types");
const WalletP2PTransport_1 = require("../transports/WalletP2PTransport");
const IncomingRequestInterceptor_1 = require("../interceptors/IncomingRequestInterceptor");
const OutgoingResponseInterceptor_1 = require("../interceptors/OutgoingResponseInterceptor");
const logger = new beacon_core_1.Logger('WalletClient');
/**
 * @publicapi
 *
 * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible
 * dapps and handling/responding to requests.
 *
 * @category Wallet
 */
class WalletClient extends beacon_core_1.Client {
    get isConnected() {
        return this._isConnected.promise;
    }
    constructor(config) {
        super(Object.assign({ storage: config && config.storage ? config.storage : new beacon_core_1.LocalStorage() }, config));
        /**
         * Returns whether or not the transport is connected
         */
        this._isConnected = new beacon_utils_1.ExposedPromise();
        /**
         * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.
         */
        this.pendingRequests = [];
        this.permissionManager = new beacon_core_1.PermissionManager(this.storage);
        this.appMetadataManager = new beacon_core_1.AppMetadataManager(this.storage);
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues
            const p2pTransport = new WalletP2PTransport_1.WalletP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
            return _super.init.call(this, p2pTransport);
        });
    }
    /**
     * This method initiates a connection to the P2P network and registers a callback that will be called
     * whenever a message is received.
     *
     * @param newMessageCallback The callback that will be invoked for every message the transport receives.
     */
    connect(newMessageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handleResponse = (message, connectionContext) => __awaiter(this, void 0, void 0, function* () {
                if (message.version === '3') {
                    const typedMessage = message;
                    if (typedMessage.message.type === beacon_types_1.BeaconMessageType.Disconnect) {
                        return this.disconnect(typedMessage.senderId);
                    }
                    if (!this.pendingRequests.some((request) => request[0].id === message.id)) {
                        this.pendingRequests.push([typedMessage, connectionContext]);
                        yield this.sendAcknowledgeResponse(typedMessage, connectionContext);
                        yield IncomingRequestInterceptor_1.IncomingRequestInterceptor.intercept({
                            message: typedMessage,
                            connectionInfo: connectionContext,
                            appMetadataManager: this.appMetadataManager,
                            interceptorCallback: newMessageCallback
                        });
                    }
                }
                else {
                    const typedMessage = message;
                    if (typedMessage.type === beacon_types_1.BeaconMessageType.Disconnect) {
                        return this.disconnect(typedMessage.senderId);
                    }
                    if (!this.pendingRequests.some((request) => request[0].id === message.id)) {
                        this.pendingRequests.push([typedMessage, connectionContext]);
                        if (typedMessage.version !== '1') {
                            yield this.sendAcknowledgeResponse(typedMessage, connectionContext);
                        }
                        yield IncomingRequestInterceptor_1.IncomingRequestInterceptor.intercept({
                            message: typedMessage,
                            connectionInfo: connectionContext,
                            appMetadataManager: this.appMetadataManager,
                            interceptorCallback: newMessageCallback
                        });
                    }
                }
            });
            return this._connect();
        });
    }
    getRegisterPushChallenge(backendUrl, accountPublicKey, oracleUrl = beacon_core_1.NOTIFICATION_ORACLE_URL) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check if account is already registered
            const challenge = (yield axios_1.default.get(`${oracleUrl}/challenge`))
                .data;
            const constructedString = [
                'Tezos Signed Message: ',
                challenge.id,
                challenge.timestamp,
                accountPublicKey,
                backendUrl
            ].join(' ');
            const bytes = (0, beacon_utils_1.toHex)(constructedString);
            const payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
            return {
                challenge,
                payloadToSign: payloadBytes
            };
        });
    }
    registerPush(challenge, signature, backendUrl, accountPublicKey, protocolIdentifier, deviceId, oracleUrl = beacon_core_1.NOTIFICATION_ORACLE_URL) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokens = yield this.storage.get(beacon_types_1.StorageKey.PUSH_TOKENS);
            const token = tokens.find((el) => el.publicKey === accountPublicKey && el.backendUrl === backendUrl);
            if (token) {
                return token;
            }
            const register = (yield axios_1.default.post(`${oracleUrl}/register`, {
                name: this.name,
                challenge,
                accountPublicKey,
                signature,
                backendUrl,
                protocolIdentifier,
                deviceId
            })).data;
            const newToken = {
                publicKey: accountPublicKey,
                backendUrl,
                accessToken: register.accessToken,
                managementToken: register.managementToken
            };
            tokens.push(newToken);
            yield this.storage.set(beacon_types_1.StorageKey.PUSH_TOKENS, tokens);
            return newToken;
        });
    }
    /**
     * The method will attempt to initiate a connection using the active transport.
     */
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = (yield this.transport);
            if (transport.connectionStatus === beacon_types_1.TransportStatus.NOT_CONNECTED) {
                yield transport.connect();
                transport
                    .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {
                    if (typeof message === 'string') {
                        const deserializedMessage = (yield new beacon_core_1.Serializer().deserialize(message));
                        this.handleResponse(deserializedMessage, connectionInfo);
                    }
                }))
                    .catch((error) => logger.log('_connect', error));
                this._isConnected.resolve(true);
            }
            else {
                // NO-OP
            }
        });
    }
    /**
     * This method sends a response for a specific request back to the DApp
     *
     * @param message The BeaconResponseMessage that will be sent back to the DApp
     */
    respond(message) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('RESPONSE', message);
            const request = this.pendingRequests.find((pendingRequest) => pendingRequest[0].id === message.id);
            if (!request) {
                throw new Error('No matching request found!');
            }
            this.pendingRequests = this.pendingRequests.filter((pendingRequest) => pendingRequest[0].id !== message.id);
            yield OutgoingResponseInterceptor_1.OutgoingResponseInterceptor.intercept({
                senderId: yield (0, beacon_core_1.getSenderId)(yield this.beaconId),
                request: request[0],
                message,
                ownAppMetadata: yield this.getOwnAppMetadata(),
                permissionManager: this.permissionManager,
                appMetadataManager: this.appMetadataManager,
                interceptorCallback: (response) => __awaiter(this, void 0, void 0, function* () {
                    yield this.respondToMessage(response, request[1]);
                })
            });
        });
    }
    getAppMetadataList() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.getAppMetadataList();
        });
    }
    getAppMetadata(senderId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.getAppMetadata(senderId);
        });
    }
    removeAppMetadata(senderId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.removeAppMetadata(senderId);
        });
    }
    removeAllAppMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.removeAllAppMetadata();
        });
    }
    getPermissions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.getPermissions();
        });
    }
    getPermission(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.getPermission(accountIdentifier);
        });
    }
    removePermission(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.removePermission(accountIdentifier);
        });
    }
    removeAllPermissions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.removeAllPermissions();
        });
    }
    getPeerInfo(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const senderId = yield (0, beacon_core_1.getSenderId)(peer.publicKey);
            if (peer instanceof beacon_types_1.PostMessagePairingRequest) {
                return new beacon_types_1.ExtendedPostMessagePairingRequest(peer.id, peer.name, peer.publicKey, peer.version, senderId);
            }
            else if (peer instanceof beacon_types_1.P2PPairingRequest) {
                return new beacon_types_1.ExtendedP2PPairingRequest(peer.id, peer.name, peer.publicKey, peer.version, peer.relayServer, senderId);
            }
            else if (peer instanceof beacon_types_1.ExtendedWalletConnectPairingRequest) {
                return new beacon_types_1.ExtendedWalletConnectPairingRequest(peer.id, peer.name, peer.publicKey, peer.version, senderId, peer.uri);
            }
            else {
                return Object.assign(Object.assign({}, peer), { senderId });
            }
        });
    }
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    addPeer(peer, sendPairingResponse = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.transport).addPeer(yield this.getPeerInfo(peer), sendPairingResponse);
        });
    }
    removePeer(peer, sendDisconnectToPeer = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const removePeerResult = (yield this.transport).removePeer(peer);
            yield this.removePermissionsForPeers([peer]);
            if (sendDisconnectToPeer) {
                yield this.sendDisconnectToPeer(peer);
            }
            return removePeerResult;
        });
    }
    removeAllPeers(sendDisconnectToPeers = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const peers = yield (yield this.transport).getPeers();
            const removePeerResult = (yield this.transport).removeAllPeers();
            yield this.removePermissionsForPeers(peers);
            if (sendDisconnectToPeers) {
                const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer));
                yield Promise.all(disconnectPromises);
            }
            return removePeerResult;
        });
    }
    removePermissionsForPeers(peersToRemove) {
        return __awaiter(this, void 0, void 0, function* () {
            const permissions = yield this.permissionManager.getPermissions();
            const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);
            // Remove all permissions with origin of the specified peer
            const permissionsToRemove = permissions.filter((permission) => peerIdsToRemove.includes(permission.appMetadata.senderId));
            const permissionIdentifiersToRemove = permissionsToRemove.map((permissionInfo) => permissionInfo.accountIdentifier);
            yield this.permissionManager.removePermissions(permissionIdentifiersToRemove);
        });
    }
    /**
     * Send an acknowledge message back to the sender
     *
     * @param message The message that was received
     */
    sendAcknowledgeResponse(request, connectionContext) {
        return __awaiter(this, void 0, void 0, function* () {
            // Acknowledge the message
            const acknowledgeResponse = {
                id: request.id,
                type: beacon_types_1.BeaconMessageType.Acknowledge
            };
            yield OutgoingResponseInterceptor_1.OutgoingResponseInterceptor.intercept({
                senderId: yield (0, beacon_core_1.getSenderId)(yield this.beaconId),
                request,
                message: acknowledgeResponse,
                ownAppMetadata: yield this.getOwnAppMetadata(),
                permissionManager: this.permissionManager,
                appMetadataManager: this.appMetadataManager,
                interceptorCallback: (response) => __awaiter(this, void 0, void 0, function* () {
                    yield this.respondToMessage(response, connectionContext);
                })
            });
        });
    }
    /**
     * An internal method to send a BeaconMessage to the DApp
     *
     * @param response Send a message back to the DApp
     */
    respondToMessage(response, connectionContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedMessage = yield new beacon_core_1.Serializer().serialize(response);
            if (connectionContext) {
                const peerInfos = yield this.getPeers();
                const peer = peerInfos.find((peerInfo) => peerInfo.publicKey === connectionContext.id);
                yield (yield this.transport).send(serializedMessage, peer);
            }
            else {
                yield (yield this.transport).send(serializedMessage);
            }
        });
    }
    disconnect(senderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = yield this.transport;
            const peers = yield transport.getPeers();
            const peer = peers.find((peerEl) => peerEl.senderId === senderId);
            if (peer) {
                yield this.removePeer(peer);
            }
            return;
        });
    }
}
exports.WalletClient = WalletClient;
//# sourceMappingURL=WalletClient.js.map