import axios from 'axios';
import { Serializer, Client, LocalStorage, PermissionManager, AppMetadataManager, getSenderId, Logger, NOTIFICATION_ORACLE_URL } from '@airgap/beacon-core';
import { ExposedPromise, toHex } from '@airgap/beacon-utils';
import { BeaconMessageType, TransportStatus, StorageKey, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedWalletConnectPairingRequest } from '@airgap/beacon-types';
import { WalletP2PTransport } from '../transports/WalletP2PTransport';
import { IncomingRequestInterceptor } from '../interceptors/IncomingRequestInterceptor';
import { OutgoingResponseInterceptor } from '../interceptors/OutgoingResponseInterceptor';
const logger = new Logger('WalletClient');
/**
 * @publicapi
 *
 * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible
 * dapps and handling/responding to requests.
 *
 * @category Wallet
 */
export class WalletClient extends Client {
    /**
     * Returns whether or not the transport is connected
     */
    _isConnected = new ExposedPromise();
    get isConnected() {
        return this._isConnected.promise;
    }
    permissionManager;
    appMetadataManager;
    /**
     * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.
     */
    pendingRequests = [];
    constructor(config) {
        super({
            storage: config && config.storage ? config.storage : new LocalStorage(),
            ...config
        });
        this.permissionManager = new PermissionManager(this.storage);
        this.appMetadataManager = new AppMetadataManager(this.storage);
    }
    async init() {
        const keyPair = await this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues
        const p2pTransport = new WalletP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
        return super.init(p2pTransport);
    }
    /**
     * This method initiates a connection to the P2P network and registers a callback that will be called
     * whenever a message is received.
     *
     * @param newMessageCallback The callback that will be invoked for every message the transport receives.
     */
    async connect(newMessageCallback) {
        this.handleResponse = async (message, connectionContext) => {
            if (message.version === '3') {
                const typedMessage = message;
                if (typedMessage.message.type === BeaconMessageType.Disconnect) {
                    return this.disconnect(typedMessage.senderId);
                }
                if (!this.pendingRequests.some((request) => request[0].id === message.id)) {
                    this.pendingRequests.push([typedMessage, connectionContext]);
                    await this.sendAcknowledgeResponse(typedMessage, connectionContext);
                    await IncomingRequestInterceptor.intercept({
                        message: typedMessage,
                        connectionInfo: connectionContext,
                        appMetadataManager: this.appMetadataManager,
                        interceptorCallback: newMessageCallback
                    });
                }
            }
            else {
                const typedMessage = message;
                if (typedMessage.type === BeaconMessageType.Disconnect) {
                    return this.disconnect(typedMessage.senderId);
                }
                if (!this.pendingRequests.some((request) => request[0].id === message.id)) {
                    this.pendingRequests.push([typedMessage, connectionContext]);
                    if (typedMessage.version !== '1') {
                        await this.sendAcknowledgeResponse(typedMessage, connectionContext);
                    }
                    await IncomingRequestInterceptor.intercept({
                        message: typedMessage,
                        connectionInfo: connectionContext,
                        appMetadataManager: this.appMetadataManager,
                        interceptorCallback: newMessageCallback
                    });
                }
            }
        };
        return this._connect();
    }
    async getRegisterPushChallenge(backendUrl, accountPublicKey, oracleUrl = NOTIFICATION_ORACLE_URL) {
        // Check if account is already registered
        const challenge = (await axios.get(`${oracleUrl}/challenge`))
            .data;
        const constructedString = [
            'Tezos Signed Message: ',
            challenge.id,
            challenge.timestamp,
            accountPublicKey,
            backendUrl
        ].join(' ');
        const bytes = toHex(constructedString);
        const payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
        return {
            challenge,
            payloadToSign: payloadBytes
        };
    }
    async registerPush(challenge, signature, backendUrl, accountPublicKey, protocolIdentifier, deviceId, oracleUrl = NOTIFICATION_ORACLE_URL) {
        const tokens = await this.storage.get(StorageKey.PUSH_TOKENS);
        const token = tokens.find((el) => el.publicKey === accountPublicKey && el.backendUrl === backendUrl);
        if (token) {
            return token;
        }
        const register = (await axios.post(`${oracleUrl}/register`, {
            name: this.name,
            challenge,
            accountPublicKey,
            signature,
            backendUrl,
            protocolIdentifier,
            deviceId
        })).data;
        const newToken = {
            publicKey: accountPublicKey,
            backendUrl,
            accessToken: register.accessToken,
            managementToken: register.managementToken
        };
        tokens.push(newToken);
        await this.storage.set(StorageKey.PUSH_TOKENS, tokens);
        return newToken;
    }
    /**
     * The method will attempt to initiate a connection using the active transport.
     */
    async _connect() {
        const transport = (await this.transport);
        if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {
            await transport.connect();
            transport
                .addListener(async (message, connectionInfo) => {
                if (typeof message === 'string') {
                    const deserializedMessage = (await new Serializer().deserialize(message));
                    this.handleResponse(deserializedMessage, connectionInfo);
                }
            })
                .catch((error) => logger.log('_connect', error));
            this._isConnected.resolve(true);
        }
        else {
            // NO-OP
        }
    }
    /**
     * This method sends a response for a specific request back to the DApp
     *
     * @param message The BeaconResponseMessage that will be sent back to the DApp
     */
    async respond(message) {
        logger.log('RESPONSE', message);
        const request = this.pendingRequests.find((pendingRequest) => pendingRequest[0].id === message.id);
        if (!request) {
            throw new Error('No matching request found!');
        }
        this.pendingRequests = this.pendingRequests.filter((pendingRequest) => pendingRequest[0].id !== message.id);
        await OutgoingResponseInterceptor.intercept({
            senderId: await getSenderId(await this.beaconId),
            request: request[0],
            message,
            ownAppMetadata: await this.getOwnAppMetadata(),
            permissionManager: this.permissionManager,
            appMetadataManager: this.appMetadataManager,
            interceptorCallback: async (response) => {
                await this.respondToMessage(response, request[1]);
            }
        });
    }
    async getAppMetadataList() {
        return this.appMetadataManager.getAppMetadataList();
    }
    async getAppMetadata(senderId) {
        return this.appMetadataManager.getAppMetadata(senderId);
    }
    async removeAppMetadata(senderId) {
        return this.appMetadataManager.removeAppMetadata(senderId);
    }
    async removeAllAppMetadata() {
        return this.appMetadataManager.removeAllAppMetadata();
    }
    async getPermissions() {
        return this.permissionManager.getPermissions();
    }
    async getPermission(accountIdentifier) {
        return this.permissionManager.getPermission(accountIdentifier);
    }
    async removePermission(accountIdentifier) {
        return this.permissionManager.removePermission(accountIdentifier);
    }
    async removeAllPermissions() {
        return this.permissionManager.removeAllPermissions();
    }
    async getPeerInfo(peer) {
        const senderId = await getSenderId(peer.publicKey);
        if (peer instanceof PostMessagePairingRequest) {
            return new ExtendedPostMessagePairingRequest(peer.id, peer.name, peer.publicKey, peer.version, senderId);
        }
        else if (peer instanceof P2PPairingRequest) {
            return new ExtendedP2PPairingRequest(peer.id, peer.name, peer.publicKey, peer.version, peer.relayServer, senderId);
        }
        else if (peer instanceof ExtendedWalletConnectPairingRequest) {
            return new ExtendedWalletConnectPairingRequest(peer.id, peer.name, peer.publicKey, peer.version, senderId, peer.uri);
        }
        else {
            return {
                ...peer,
                senderId
            };
        }
    }
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    async addPeer(peer, sendPairingResponse = true) {
        return (await this.transport).addPeer(await this.getPeerInfo(peer), sendPairingResponse);
    }
    async removePeer(peer, sendDisconnectToPeer = false) {
        const removePeerResult = (await this.transport).removePeer(peer);
        await this.removePermissionsForPeers([peer]);
        if (sendDisconnectToPeer) {
            await this.sendDisconnectToPeer(peer);
        }
        return removePeerResult;
    }
    async removeAllPeers(sendDisconnectToPeers = false) {
        const peers = await (await this.transport).getPeers();
        const removePeerResult = (await this.transport).removeAllPeers();
        await this.removePermissionsForPeers(peers);
        if (sendDisconnectToPeers) {
            const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer));
            await Promise.all(disconnectPromises);
        }
        return removePeerResult;
    }
    async removePermissionsForPeers(peersToRemove) {
        const permissions = await this.permissionManager.getPermissions();
        const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);
        // Remove all permissions with origin of the specified peer
        const permissionsToRemove = permissions.filter((permission) => peerIdsToRemove.includes(permission.appMetadata.senderId));
        const permissionIdentifiersToRemove = permissionsToRemove.map((permissionInfo) => permissionInfo.accountIdentifier);
        await this.permissionManager.removePermissions(permissionIdentifiersToRemove);
    }
    /**
     * Send an acknowledge message back to the sender
     *
     * @param message The message that was received
     */
    async sendAcknowledgeResponse(request, connectionContext) {
        // Acknowledge the message
        const acknowledgeResponse = {
            id: request.id,
            type: BeaconMessageType.Acknowledge
        };
        await OutgoingResponseInterceptor.intercept({
            senderId: await getSenderId(await this.beaconId),
            request,
            message: acknowledgeResponse,
            ownAppMetadata: await this.getOwnAppMetadata(),
            permissionManager: this.permissionManager,
            appMetadataManager: this.appMetadataManager,
            interceptorCallback: async (response) => {
                await this.respondToMessage(response, connectionContext);
            }
        });
    }
    /**
     * An internal method to send a BeaconMessage to the DApp
     *
     * @param response Send a message back to the DApp
     */
    async respondToMessage(response, connectionContext) {
        const serializedMessage = await new Serializer().serialize(response);
        if (connectionContext) {
            const peerInfos = await this.getPeers();
            const peer = peerInfos.find((peerInfo) => peerInfo.publicKey === connectionContext.id);
            await (await this.transport).send(serializedMessage, peer);
        }
        else {
            await (await this.transport).send(serializedMessage);
        }
    }
    async disconnect(senderId) {
        const transport = await this.transport;
        const peers = await transport.getPeers();
        const peer = peers.find((peerEl) => peerEl.senderId === senderId);
        if (peer) {
            await this.removePeer(peer);
        }
        return;
    }
}
//# sourceMappingURL=WalletClient.js.map