import { BeaconMessageType } from '@airgap/beacon-types';
import { Logger } from '@airgap/beacon-core';
const logger = new Logger('IncomingRequestInterceptor');
/**
 * @internalapi
 *
 * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.
 */
export class IncomingRequestInterceptor {
    /**
     * The method that is called during the interception
     *
     * @param config
     */
    static async intercept(config) {
        logger.log('INTERCEPTING REQUEST', config.message);
        if (config.message.version === '2') {
            IncomingRequestInterceptor.handleV2Message(config);
        }
        else if (config.message.version === '3') {
            IncomingRequestInterceptor.handleV3Message(config);
        }
    }
    static async getAppMetadata(appMetadataManager, senderId) {
        const appMetadata = await appMetadataManager.getAppMetadata(senderId);
        if (!appMetadata) {
            throw new Error('AppMetadata not found');
        }
        return appMetadata;
    }
    static async handleV2Message(config) {
        const { message, connectionInfo, appMetadataManager, interceptorCallback } = config;
        switch (message.type) {
            case BeaconMessageType.PermissionRequest:
                {
                    logger.log('PERMISSION REQUEST V*', message);
                    // TODO: Remove v1 compatibility in later version
                    if (message.appMetadata.beaconId && !message.appMetadata.senderId) {
                        message.appMetadata.senderId = message.appMetadata.beaconId;
                        delete message.appMetadata.beaconId;
                    }
                    await appMetadataManager.addAppMetadata(message.appMetadata);
                    const request = message;
                    interceptorCallback(request, connectionInfo);
                }
                break;
            case BeaconMessageType.OperationRequest:
                {
                    const appMetadata = await IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);
                    const request = {
                        appMetadata,
                        ...message
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            case BeaconMessageType.SignPayloadRequest:
                {
                    const appMetadata = await IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);
                    const request = {
                        appMetadata,
                        ...message
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            // TODO: ENCRYPTION
            // case BeaconMessageType.EncryptPayloadRequest:
            //   {
            //     const appMetadata: AppMetadata = await IncomingRequestInterceptor.getAppMetadata(
            //       appMetadataManager,
            //       message.senderId
            //     )
            //     const request: EncryptPayloadRequestOutput = {
            //       appMetadata,
            //       ...message
            //     }
            //     interceptorCallback(request, connectionInfo)
            //   }
            //   break
            case BeaconMessageType.BroadcastRequest:
                {
                    const appMetadata = await IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);
                    const request = {
                        appMetadata,
                        ...message
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            case BeaconMessageType.ProofOfEventChallengeRequest:
                {
                    const appMetadata = await IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);
                    const request = {
                        appMetadata,
                        ...message
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            case BeaconMessageType.ProofOfEventChallengeRecorded:
                {
                    const appMetadata = await IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);
                    const request = {
                        appMetadata,
                        ...message
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            default:
                logger.log('intercept', 'Message not handled');
                assertNever(message);
        }
    }
    static async handleV3Message(config) {
        const { message: msg, connectionInfo, appMetadataManager, interceptorCallback } = config;
        const wrappedMessage = msg; /* TODO: Remove any */
        const v3Message = wrappedMessage.message;
        switch (v3Message.type) {
            case BeaconMessageType.PermissionRequest:
                {
                    await appMetadataManager.addAppMetadata({
                        ...v3Message.blockchainData.appMetadata,
                        senderId: msg.senderId
                    }); // Make sure we use the actual senderId, not what the dApp told us
                    const request /* PermissionRequestOutput */ = wrappedMessage;
                    interceptorCallback(request, connectionInfo);
                }
                break;
            case BeaconMessageType.BlockchainRequest:
                {
                    // const appMetadata: AppMetadata = await IncomingRequestInterceptor.getAppMetadata(
                    //   appMetadataManager,
                    //   msg.senderId
                    // )
                    const request /* BeaconMessageWrapper<BlockchainRequestV3<string>> */ = {
                        ...wrappedMessage
                    };
                    interceptorCallback(request, connectionInfo);
                }
                break;
            default:
                logger.log('intercept', 'Message not handled');
                assertNever(v3Message);
        }
    }
}
function assertNever(_message) {
    throw new Error('Function not implemented.');
}
//# sourceMappingURL=IncomingRequestInterceptor.js.map