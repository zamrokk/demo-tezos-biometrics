import { getAccountIdentifier, Logger } from '@airgap/beacon-core';
import { BeaconMessageType, BeaconErrorType } from '@airgap/beacon-types';
import { getAddressFromPublicKey, CONTRACT_PREFIX, isValidAddress } from '@airgap/beacon-utils';
const logger = new Logger('OutgoingResponseInterceptor');
/**
 * @internalapi
 *
 * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.
 */
export class OutgoingResponseInterceptor {
    static async intercept(config) {
        if (config.request.version === '2') {
            OutgoingResponseInterceptor.handleV2Message(config);
        }
        else if (config.request.version === '3') {
            OutgoingResponseInterceptor.handleV3Message(config);
        }
    }
    static async handleV3Message(config) {
        const { 
        // senderId,
        // request,
        message: msg, 
        // ownAppMetadata,
        // permissionManager,
        appMetadataManager, interceptorCallback } = config;
        const wrappedMessage = msg;
        const v3Message = wrappedMessage.message;
        logger.log('LOGGING OUTGOING V3', v3Message, appMetadataManager);
        interceptorCallback(msg);
        // switch (v3Message.type) {
        //   case BeaconMessageType.PermissionResponse:
        //     {
        //       const response: PermissionResponse = {
        //         senderId,
        //         version: BEACON_VERSION,
        //         appMetadata: ownAppMetadata,
        //         ...msg
        //       }
        //       const publicKey = response.publicKey
        //       const address: string = await getAddressFromPublicKey(publicKey)
        //       const appMetadata = await appMetadataManager.getAppMetadata(request.senderId)
        //       if (!appMetadata) {
        //         throw new Error('AppMetadata not found')
        //       }
        //       const permission: PermissionInfo = {
        //         accountIdentifier: await getAccountIdentifier(address, response.network),
        //         senderId: request.senderId,
        //         appMetadata,
        //         website: '',
        //         address,
        //         publicKey,
        //         network: response.network,
        //         scopes: response.scopes,
        //         connectedAt: new Date().getTime()
        //       }
        //       permissionManager.addPermission(permission).catch(console.error)
        //       interceptorCallback(response)
        //     }
        //     break
        //   case BeaconMessageType.BlockchainResponse:
        //     {
        //       // const appMetadata: AppMetadata = await IncomingRequestInterceptor.getAppMetadata(
        //       //   appMetadataManager,
        //       //   msg.senderId
        //       // )
        //       const request: any /* BeaconMessageWrapper<BlockchainRequestV3<string>> */ = {
        //         ...wrappedMessage
        //       }
        //       interceptorCallback(request)
        //     }
        //     break
        //   default:
        //     logger.log('intercept', 'Message not handled')
        //     assertNever(v3Message)
        // }
    }
    static async handleV2Message(config) {
        const { senderId, request, message, ownAppMetadata, permissionManager, appMetadataManager, interceptorCallback } = config;
        switch (message.type) {
            case BeaconMessageType.Error: {
                const response = {
                    type: message.type,
                    version: '2',
                    senderId,
                    id: message.id,
                    errorType: message.errorType
                };
                if (message.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {
                    const errorData = message.errorData;
                    // Check if error data is in correct format
                    if (Array.isArray(errorData) &&
                        errorData.every((item) => Boolean(item.kind) && Boolean(item.id))) {
                        response.errorData = message.errorData;
                    }
                    else {
                        logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');
                    }
                }
                interceptorCallback(response);
                break;
            }
            case BeaconMessageType.Acknowledge: {
                const response = {
                    type: message.type,
                    version: '2',
                    senderId,
                    id: message.id
                };
                interceptorCallback(response);
                break;
            }
            case BeaconMessageType.PermissionResponse: {
                const response = {
                    senderId,
                    version: '2',
                    appMetadata: ownAppMetadata,
                    ...message
                };
                if (!response.address && !response.publicKey) {
                    throw new Error('Address or PublicKey must be defined');
                }
                const publicKey = response.publicKey;
                const address = response.address ?? (await getAddressFromPublicKey(publicKey));
                if (!isValidAddress(address)) {
                    throw new Error(`Invalid address: "${address}"`);
                }
                if (message.walletType === 'abstracted_account' &&
                    address.substring(0, 3) !== CONTRACT_PREFIX) {
                    throw new Error(`Invalid abstracted account address "${address}", it should be a ${CONTRACT_PREFIX} address`);
                }
                const appMetadata = await appMetadataManager.getAppMetadata(request.senderId);
                if (!appMetadata) {
                    throw new Error('AppMetadata not found');
                }
                const permission = {
                    accountIdentifier: await getAccountIdentifier(address, response.network),
                    senderId: request.senderId,
                    appMetadata,
                    website: '',
                    address,
                    publicKey,
                    network: response.network,
                    scopes: response.scopes,
                    connectedAt: new Date().getTime()
                };
                permissionManager.addPermission(permission).catch(console.error);
                interceptorCallback(response);
                break;
            }
            case BeaconMessageType.OperationResponse:
                {
                    const response = {
                        senderId,
                        version: '2',
                        ...message
                    };
                    interceptorCallback(response);
                }
                break;
            case BeaconMessageType.SignPayloadResponse:
                {
                    const response = {
                        senderId,
                        version: '2',
                        ...message
                    };
                    interceptorCallback(response);
                }
                break;
            // TODO: ENCRYPTION
            // case BeaconMessageType.EncryptPayloadResponse:
            //   {
            //     const response: EncryptPayloadResponse = {
            //       senderId,
            //       version: BEACON_VERSION,
            //       ...message
            //     }
            //     interceptorCallback(response)
            //   }
            //   break
            case BeaconMessageType.BroadcastResponse:
                {
                    const response = {
                        senderId,
                        version: '2',
                        ...message
                    };
                    interceptorCallback(response);
                }
                break;
            case BeaconMessageType.ProofOfEventChallengeResponse:
                {
                    const response = {
                        senderId,
                        version: '2',
                        ...message
                    };
                    interceptorCallback(response);
                }
                break;
            default:
                logger.log('intercept', 'Message not handled');
                assertNever(message);
        }
    }
}
function assertNever(_message) {
    throw new Error('Function not implemented.');
}
//# sourceMappingURL=OutgoingResponseInterceptor.js.map